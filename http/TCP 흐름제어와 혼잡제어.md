# TCP의 흐름제어와 혼잡제어

## 1. 흐름제어

- 송신측과 수신측의 데이터 처리 속도의 차이를 해결하기 위한 기법이다.
- 수신측의 처리속도가 더 빠르다면 문제가 없지만, 그렇지않다면 저장용량을 초과한 이후의 데이터는 유실될 가능성이 있다.



### 1-1) Stop And Wait 방식

- 송신측이 매번 전송한 패킷에 대한 확인 응답을 받은 이후에만, 다음 패킷을 수신측으로 전송하는 방법이다.
- 송신측이 일정시간 (Roung Trip Timeout)동안 수신측으로부터 확인 응답을 받지 못하면, 해당 패킷이 손실되었거나 오류가 있다고 판단하여 재전송한다.



### 1-2) Sliding Window 방식

- 송수신측이 같은 크기의 `윈도우`를 가지고 있어, 송신측이 전송한 데이터에대한 `ACK`를 받지 않았다고 하더라도 패킷을 전송할 수 있도록 하는 방식이다.
- 송신측이 수신측으로부터 `ACK` 를 받았다면, 송신측은 `윈도우`를 한칸 움직여서 그 다음 패킷을 전송한다.
- 즉, 송신측은 `윈도우` 크기만큼의 패킷을 전송하고, `ACK`를 받게되면 그때마다 `윈도우`를 슬라이딩 시켜 다음 패킷을 전송하는 기법이다.

![](http://www.ktword.co.kr//img_data/1469_1.jpg)



![](http://www.ktword.co.kr//img_data/1469_2.JPG)



## 2. 혼잡제어

- 많은 사용자들이 동시에 많은 데이터를 전송할 경우 네트워크에 지연이 발생하는 상황을 제어하기 위한 기법이다.
- 즉, 네트워크가 수용할 수 없는 데이터 전송이 발생할 때 패킷의 손실이나 지연을 막기 위해 사용된다.



### 2-1) 느린 시작 (Slow Start)

- 초기 혼잡 `윈도우`를 1로 지정하고, 수신측으로부터 `ACK`를 받을 경우, `윈도우`의 크기를 2배씩 증가시키는 방법이다.
- 전송되어지는 데이터의 크기가 미리 정해놓은 임계치에 도달하면, `혼잡 회피`단계로 넘어가게 된다.



### 2-2) 혼잡 회피 (Congetstion Avoidance)

- `혼잡 회피`알고리즘은 `느린 시작` 알고리즘을 통해 혼잡 윈도우의 크기가 지수배 만큼 증가하다가, 혼잡 윈도우의 임계치에 도달하면 적용되는 알고리즘이다.
- 즉, 혼잡 윈도우의 값을 1씩 증가시키면서 네트워크의 혼잡 상태를 감지하기 위해 작동한다.
- 만약, `혼잡 감지` 단계에서 수신측으로부터 ACK를 받지 못하거나 타임아웃되면 `혼잡 동작` 단계로 넘어가는데, 이때 윈도우의 값은 1로 리셋되고, `혼잡 윈도우`의 한계 값은 현재 `혼잡 윈도우`크기의 절반으로 수정된다.



### *문제*

혼잡 윈도우의 임계치가 16이고, t = 8 ms에서 RTO의 값이 타임아웃 된다고 가정했을 때, 혼잡 제어 과정이 어떻게 진행되는지 설명하라.



### 해결

1. 초기 값으로 `혼잡 윈도우`의 값을 1로 설정하고 혼잡 제어를 수행한다.

2. 이때 `느린 출발` 알고리즘을 적용하여 `혼잡 윈도우`의 크기를 2, 4, 8, .....로 증가시킨다.
3. t = 4ms에서 `혼잡 윈도우`크기가 임계치인 16이 되면  `혼잡 회피` 알고리즘이 적용된다.
4. 즉, `혼잡 윈도우`의 크기는 16부터는 17, 18, 19, 20....처럼 1씩 증가된다.
5. t = 8ms 에서 `혼잡 윈도우`의 크기는 20인데, 이때 타임아웃이 발생하면 `혼잡 윈도우`의 임계치를 20 / 2 = 10으로 변경한다.
6. 이후에는, 다시 `느린 출발` 알고리즘이 적용되어 `혼잡 윈도우`의 크기는 2, 4, 8, ...로 증가하며 위의 과정을 반복한다.