# 커넥션 관리



## 1. TCP 커넥션

- HTTP 통신은, 패킷 교환 네트워크 프로토콜의 계층화된 집합인 TCP/IP를 통해 이루어진다.
- 일단, 커넥션이 맺어지면 `서버`와 `클라이언트`간에 주고받는 메시지는 손실되거나 순서가 뒤바뀌지 않는다.



### 1-1) TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 `TCP` 커넥션을 통해서 메시지를 순서대로 보낸다.
- `TCP`는 `세그먼트`라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트롤 `IP패킷`이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.



### 1-2) TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트번호를 통해서 이런 여러 개의 커넥션을 유지한다.
- TCP 커넥션은 **<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>**처럼 네 가지 값으로 식별한다.

---



## 2. TCP 성능에 대한 고려

- 트랜잭션을 처리하는 시간은 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다고 할 수 있다.
- 클라이언트나 서버가 너무 큰 용량의 데이터를 다루지 않는한, 대부분의 HTTP지연은 TCP의 지연때문에 발생한다.



### 2-1) TCP 커넥션 핸드셰이크 지연

- 어떤 데이터를 전송하든, 새로운 TCP 커넥션을 열 때면, 커넥션을 맺기 위해 연속적으로 IP 패킷을 교환한다.
- 작은 크기의 데이터 전송에 TCP 커넥션이 사용된다면, 이런 패킷 교환은 HTTP 성능을 저하시킬 수 있다.



![TCP 핸드셰이크 과정](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfs4.tistory.com%2Fupload_control%2Fdownload.blog%3Ffhandle%3DYmxvZzQ1ODUxQGZzNC50aXN0b3J5LmNvbTovYXR0YWNoLzAvOS5wbmc%253D)

1) 클라이언트는 새로운 TCP 커넥션을 맺기 위해 작은 TCP 패킷을 서버에게 보낸다. 그 패킷은, `SYN`이라는 특별한 플래그를 가지는데, 이 요청이 커넥션 생성 요청이라는 뜻이다.

2) 서버는 커넥션 요청이 받아들여졌음을 의미하는 `SYN`와 `ACK` 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.

3) 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에게 다시 확인 응답 신호를 보낸다.



### 2-2) Delayed acknowledgment (확인 응답 지연)

- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에 TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.
- 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인 응답 패킷(`ACK`)를 송신자에게 반환한다.
- 만약, 송신자가 특정시간(`RTO`) 동안  확인 응답 패킷(`ACK`)를 받지 못하면, 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다(`Stop-And-Wait 방식`).
- 확인 응답 패킷(`ACK`)는 그 크기가 작기 때문에 같은 방향으로 보내는 데이터에 확인응답을 편승(`piggyback`)시킨다.

- **`확인 응답 지연`은 송출할 확인 응답을 특정 시간동안 버퍼에 저장해두고, 확인 응답을 편승시키기 위한 송출 데이터 패킷을 찾는다.**
- **막상 편승할 패킷을 찾으려고하면 해당 방향으로 송출되는 패킷이 많지 않기 때문에, 확인 응답 지연 알고리즘으로 인한 지연이 자주 발생한다.**



### **더 알아보기**

1. **RTT(Round Trip Time)**
   - `서버`가 패킷을 전송한 뒤, `클라이언트`로부터 확인 응답 패킷을 받는데 걸리는 시간
2. **RTO(Rount Trip Timeout)**
   - `서버`가 확인 응답 패킷을 기다려야하는 시간으로써, 이 시간이 지나면 `서버`는 패킷이 손실되었거나 오류가 있는 것으로 판단하고, 데이터를 다시 전송한다.
3. **TCP 흐름제어**
   - [참고]()



### 2-3) TCP Slow Start

- `TCP`의 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있다.

- `TCP`커넥션은 시간이 지나면서 자체적으로 `튜닝`이 되어서, 처음에는 커넥션의 최대 속도를 제한하고, 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나가는 방식이다.

- 이는 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 쓰이는데, 이를 혼잡 윈도우를 연다.(`Opening the congestion window` )라고 한다.

  

### 2-4) 네이글(Naggle) 알고리즘과 TCP_NODELAY

- TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 보낸다면 그 만큼 네트워크의 성능은 떨어지게 된다.
- 네이글 알고리즘은 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않지만 다른 모든 패킷들이 확인 응답을 받았다면 전송을 허락한다.

### * 네이글 알고리즘의 문제점

1. 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 떄문에, 앞으로 생길지 생기지 않을지도 모르는 추가적인 데이터를 기다리며 지연된다.
2. `확인 응답 지연`과 함께 쓰일 경우 성능이 굉장히 떨어진다. 네이글 알고리즘은 확인 응답이 도착할 때 까지 데이터 전송을 멈추고 있는 반면, 확인 응답 지연 알고리즘은 확인 응답을 지연시킨다.

---



## 3. HTTP 커넥션 관리

- 3개의 이미지를 갖는 웹 페이지가 있다고 해보자.
- 브라우저에서 이 페이지를 보여주려면, 총 4개의 HTTP 커넥션이 필요하게 된다. (HTML 1개, 이미지 3개)
- 아래 그림처럼, 각 트랜잭션이 새로운 커넥션을 필요로 한다면 커넥션을 맺는데 발생하는 지연이 발생할 것이다.

![](https://t1.daumcdn.net/cfile/tistory/256BF84258DCA96E11)



### 3-1) 병렬 커넥션

- HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.
- 아래 그림은 HTML 페이지를 먼저 내려받고, 병렬 커넥션을 이용하여 남은 이미지 3개를 받는 상황이다.
- 하지만, 다수의 커넥션은 다수의 메모리를 소모하기 때문에 브라우저는 실제로 적은 수의 병렬 커넥션만을 허용한다.

![](https://t1.daumcdn.net/cfile/tistory/2662FA4658DCB36C1C)



### 3-2) 지속 커넥션

- 