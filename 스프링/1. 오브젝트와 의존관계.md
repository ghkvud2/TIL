# 1. 오브젝트와 의존관계

### 1. 개방 폐쇄 원칙 (Open-Closed Principle)

- 클래스나 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
- 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어있는 반면에 인터페이스를 사용함으로써 확장 포인트를 넗혀갈 수 있다.

```java
public class ExcelDownLoader{
    
    private DownLoader downLoader;
    
    public ExcelDownLoader(DownLoader downLoader){
        this.downLoader = downLoader;
    }
    .....
}
```

- 위의 `ExcelDownLoader`클래스는 `DownLoader` 인터페이스를 구현하는 클래스를 생성자로 전달받는다.
- `ExcelDownLoader` 클래스 입장에서 본인의  본연의 기능을 수정하지 않고도, `DownLoader` 인터페이스를 구현한 클래스들을 전달받음으로써 자유롭게 확장할 수 있다.

---

### 2. 높은 응집도와 낮은 결합도

- `OCP` 원칙은 `높은 응집도와 낮은 결합도`라는 개발 원리로도 설명할 수 있다.
- `응집도`가 높다는 것은 하나의 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 것이다.
- **불필요하거나 직접 관련이 없는** 외부의 관심과 책임에는 얽매이지 않고, 하나의 공통 관심사는 한 클래스에 모여있다는 것이다.



#### 2-1) 높은 응집도

- `응집도`가 높다는 것은 요구사항이 변할 때, 해당 모듈이나 클래스에서 변경되는 부분이 크다는 것이다.

- 즉, 변경이 일어날 때 많은 부분이 함께 변한다면 `응집도`가 높다고 할 수 있다.

  #### **응집도가 낮다면?**

  - 응집도가 낮은 경우에는, 모듈이나 클래스 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 하고, 또 그 변경으로 인해 바뀌지 않는 부분에는 다른 영향을 미치지 않는지 확인해야 하는 **이중의 부담**이 생긴다.



#### 2-2) 낮은 결합도

- `결합도`란 하나의 오브젝트에서 변경이 일어날 때, 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도로 이해할 수 있다.
- 예를 들어, 위의 `ExcelDownLoader`클래스가 전달받는 `DownLoader` 인터페이스를 구현하는 클래스가 변경이 생겼다고 생각해보자.
- `DownLoader` 인터페이스를 구현하는 클래스에 변경이 생긴다 하더라도 `ExcelDownLoader` 입장에서는 전달받는 구현 클래스가  `DownLoader`  인터페이스 구현체이기만 하면 되기 때문에 전혀 상관없이 동작할 수 있다.



#### 2-3) 전략패턴

- 전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 알고리즘 클래스를 필요에 따라서 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
- 위에서 예를 들었던 `DownLoader` 인터페이스를 구현하는 두 개의 클래스를 살펴보자.

```java
public interface DownLoader{
    void download();
}

public class TextDownLoader implements DownLoader{
    void download(){
        .....
    }
}

public class ImageDownLoader implements DownLoader{
    void download(){
        .....
    }
}
```

- `ExcelDownLoader` 입장에서는 다운받을 데이터의 포맷이 `텍스트`라면 `TextDownLoader` 객체를 전달받고, `이미지`라면 `ImageDownLoader`객체를 전달받음으로써 적절한 알고리즘을 수행할 수 있다.
- 이처럼, 컨텍스트(ExcelDownLoader)가 사용할 알고리즘 전략을 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

---

### 3. 제어 관계 역전 (IoC)

- 제어의 역전이라는 개념은 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 할 수 있다.

#### 3-1) 일반적은 프로그램의 흐름

- 일반적인 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 생성한 뒤에, 그 오브젝트의 메소드를 호출하는 방식으로 진행된다.
- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고 어떻게 그 오브젝트를 만들지 스스로 관장한다.

#### 3-2) 제어의 역전에서의 흐름

- 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도 생성하지도 않는다.
- 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문에, 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
- 위의 예제를 살펴보면, `DownLoader` 인터페이스를 구현하는 클래스들은 자신이 어떻게 사용될지 알 수 없다.
- 다만, `DownLoader`인터페이스를 구현하면, 다른 대상에 의해서 자신이 사용될 수 있도록 하는 것이다.

#### **템플릿 메소드 패턴에서 제어의 역전의 개념이 적용된다.**

---

### 4. 라이브러리 vs 프레임워크

#### 4-1) 라이브러리

- 라이브러리를 사용하는 어플리케이션 코드는 흐름을 직접 제어한다.
- 단지 동작하는 도중에 필요한 기능이 있을 때, 능동적으로 라이브러리를 사용할 뿐이다.



#### 4-2) 프레임워크

- 라이브러리와 다르게 프레임워크는 거꾸로 어플리케이션 코드가 프레임워크에 의해서 사용된다.
- 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에, 개발자가 만든 어플리케이션 코드를 사용하도록 만드는 방식이다.

---

### 5. 스프링의 IoC



#### 5-1) 어플리케이션 컨텍스트

- `스프링 빈`은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.
- 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 `빈 팩토리` 혹은 `어플리케이션 컨텍스트`라고 부른다.
- `어플리케이션 컨텍스트`는 별도의 정보를 참고해서 `빈`의 생성, 관계설정 등의 제어 작업을 총괄하는데, `어플리케이션 컨텍스트`가 직접 이런 정보를 담고 있는 것이 아니라, 별도로 설정 정보를 담고있는 무엇인가를 가져와 이를 활용하는 범용적인 `IoC` 엔진 같은 것이라고 볼 수 있다.



#### 5-2) 어플리케이션 컨텍스트 만들기

- 우선, 설정정보를 담고있는 클래스를 생성하자.

```JAVA
@Configuration
public class Factory{
    @Bean
    public ExcelDownLoader excelDownLoader(){
        return new ExcelDownLoader(downLoader());
    }
    
    @Bean
    public DownLoader downLoader(){
		return new ImageDownLoader();
    }
}
```

- `@Configuration`은 설정을 담당하는 클래스라고 인식할 수 있도록 붙여주는 어노테이션이다.
- `@Bean`은 어플리케이션 컨텍스트에 의해서 생성될 `빈` 객체임을 명시해주기 위해 붙이는 어노테이션이다.

#### 

- `어플리케이션 컨텍스트`가 사용할 수 있는 설정정보를 자바 클래스로 구성해보자.

```java
public Class DownLoaderTest{
    
    public static void main(String[] args){
    	ApplicationContext ctx = new AnnotationConfigApplicationContext(Factory.class);
        ExcelDownLoader ex = ctx.getBean("excelDownLoader", ExcelDownLoader.class);
    }
}
```

- `Factory`클래스처럼 `@Configuration`이 붙은 설정 정보를 사용하기 위해서는 `AnnotationConfigApplicationContext` 클래스를 이용하면 된다.
- 그 다음, `getBean()` 메소드를 통해 `빈`객체를 가져올 수 있다.



#### 5-3) 스프링 IoC의 용어 정리

1. 빈(bean)

- `빈`은 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다.
- 주의할 점은, 스프링을 사용하는 어플리케이션에서 만들어지는 모든 오브젝트가 다 `빈`은 아니다.
- 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 `빈`이라고 한다.



2. 빈 팩토리(bean factory)

- 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다.
- 빈을 등록하고, 생성하고, 조회하고, 돌려주고 그외에 부가적인 관리하는 기능을 담당한다.



3. 어플리케이션 컨텍스트

- 빈 팩토리를 확장한 IoC 컨테이너다. 
- 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 어플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 기능을 모두 포함해서 얘기하는 것이라고 보면 된다.



#### 5-4) 싱글톤 레지스트리로서의 어플리케이션 컨텍스트

- 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 `빈`을 모두 싱글톤으로 생성한다.
- 여기서 싱글톤은 디자인 패턴에 나오는 싱글톤 패턴과 유사하지만 그 구현 방법은 확연히 다르다.



#### 왜 스프링은 싱글톤으로 빈을 만들까?

- 스프링이 주로 적용되는 대상은 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.
- 매번 클라이언트로 요청이 올 때 마다 각 로직을 담당하는 오브젝트를 새로 생성해서 사용하다보면, 서버에 큰 부하를 줄 수 있다.
- 그래서, 스프링은 오브젝트를 하나만 만들어두고 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

#### [싱글톤에 대해서는 나중에......]

---

### 6. 의존관계 주입(DI)

- 임의의 오브젝트가 다른 오브젝트들과 동적으로 의존관계를 맺을 수 있도록 외부로부터 다른 오브젝트 레퍼런스를 전달(주입)하는 것을 DI라고 부른다.



#### 6-1) 의존관계

- A가 B에 의존하고 있다는 뜻은, A가 내부적으로 B를 사용하고 있다는 뜻이다.
- 즉, B에 기능이 추가 및 변경되면 A에도 그 영향을 미친다는 것이다. (반대로는 그렇지 않다.)
- 위에서 살펴봤던 예제를 다시 보자.

```JAVA
public class ExcelDownLoader{
    
    private DownLoader downLoader;
    
    public ExcelDownLoader(DownLoader downLoader){
        this.downLoader = downLoader;
    }
    .....
}

public interface DownLoader{
    void download();
}

public class TextDownLoader implements DownLoader{
    void download(){
        .....
    }
}

public class ImageDownLoader implements DownLoader{
    void download(){
        .....
    }
}
```

- 위처럼, `ExcelDownLoader` 클래스는 `DownLoader` 인터페이스에 의존하고 있다.
- 즉, `DownLoader` 인터페이스가 변경되면  `ExcelDownLoader`클래스에도 영향을 미친다는 것이다.
- 하지만, `DownLoader` 인터페이스를 구현하는 클래스들이 변경된다고 할지라도, `ExcelDownLoader` 클래스에는 전혀 영향을 끼치지 않는다.
- 이처럼, 인터페이스에 대해서만 의존 관계를 만들어두면 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.



#### 6-2 런타임 의존관계 설정

- 인터페이스를 통해 설계 시점에 느슨한 의존 관계를 갖는 경우에는 `ExcelDownLoader` 오브젝트가 런타임시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수 없다.
- 프로그램이 시작되고 `ExcelDownLoader`  오브젝트가 만들어지고 나서 런타임 시에 의존 관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 `의존 오브젝트`라고 한다.
- `의존 관계 주입`은 이렇게 구체적인 `의존 오브젝트`와 그것을 사용할 주체라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다.



#### 의존 관계 주입을 정리하면 다음과 같다.

1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
3. 의존 관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

