### 1. HTTP (Hyper Text Transfer Protocol)란?

- `HTTP`는 클라이언트와 서버 사이에 이루어지는 `요청과 응답` 프로토콜이다.
- 클라이언트 (웹 브라우저)가 HTTP를 통하여 서버에 리소스를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 클라이언트에게 전달해준다.



#### [클라이언트 요청]

```HTTP
GET /restapi/v1.0 HTTP/1.1
Accept: application/json
Authorization: Bearer UExBMDFUMDRQV1MwMnzpdvtYYNWMSJ7CL8h0zM6q6a9ntw
```

#### [서버 응답]

```HTTP
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Encoding: UTF-8
Content-Length: 138
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: "3f80f-1b6-3e1cb03b"
Accept-Ranges: bytes
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>
```



### HTTP 메소드

#### 1.1 GET

- `GET`요청은 서버로부터 리소스를 요청할 때 사용하는 메소드이다.

#### 1.2 HEAD

- `GET` 요청과 동일하지만, 서버로부터의 응답에는 본문이 포함되어 있지 않는 응답을 받는다.
- `HEAD`는 `GET` 메소드로 요청하는 경우에 어떤 헤더들이 반환되는지를 요청한다.
- 예를 들어, 큰 용량의 리소스를 다운로드 받을지 말지 결정하거나 리소스의 수정 날짜가 언제인지 확인하거나 해당 리소스가 서버에 존재하는지 아닌지를 확인할 때 사용한다.

#### 1.3. POST

- `POST` 요청은 서버로 데이터를 전송하고 새로운 리소스 생성을 요청한다.
- 새로운 자원이 만들어진 경우에는 `201(created)` 코드로 응답하며 신규 생성된 자원의 위치를 응답 헤더에 포함시킨다.

#### 1.4 PUT

- `PUT` 요청은 `POST`와 거의 유사하지만 `식별자의 자원`을 HTTP 메세지로 넘어온 엔티티로 교체한다.
- 다만, `PUT`요청으로 넘어온 식별자가 반드시 존재할 필요는 없는데, 이런 경우에는 넘어온 식별자를 ID로 하는 새로운 자원을 생성하고 `201(created)` 코드를 응답한다.

#### ** POST와 PUT의 차이점

- `PUT과 POST`의 차이점을 이해하기 위해서는 멱등성(idempotent)의 개념을 알아야 한다.
- 즉, 몇 번이고 같은 연산을 하더라도 같은 값이 나온다는 것이다.
- `POST`는 멱등이 아니고, `PUT`은 멱등인데 아래의 클라이언트 요청을 보자.

```HTTP
POST /dogs HTTP 1.1
{"name" : "blue", "age" : 5}
```

- `POST`는 클라이언트가 리소스의 위치를 정하지 않았을 때 리소스를 생성하기 위한 연산이다.
- 클라이언트가  `/dogs` 경로로 엔티티를 `POST`요청했다고 가정하자.
- 이 요청을 처음 보내면 `/dogs/1` 이 생기고, 그 다음에는 `/dogs/2` 가 생기는 등 매번 다른 곳에 새로운 리소스가 생성될 수 있으므로 이 연산은 멱등(idempotent)가 아니다.



- 반면 아래와 같이 리소스의 위치가 정확히 명시된 요청을 살펴보자

```http
PUT /dogs/3 HTTP 1.1
{"name" : "blue", "age" : 10}
```

- 즉, 특정 리소스의 식별자를 가지고 `PUT` 요청을 보내면 새로운 리소스를 생성하는 것이 아니라 해당 식별자에 해당하는 리소스의 값을 변경한다.
- 즉, 위의 요청을 여러 번 보내더라도 같은 결과를 보장하므로 멱등성의 특징을 갖는다고 할 수 있다.

#### 1.5 PATCH

- `PUT` 요청과 비슷하게 `UPDATE` 연산을 수행하지만, 다른 점은 자원의 일부 필드만을 교체한다는 특징이 있다.
- `POST` 방식은 해당 식별자에 해당하는 리소스의 모든 필드를 교체하지만, `PATCH` 방식은 해당 식별자에 해당하는 리소스 중에서 변경하고자 하는 필드만을 수정할 수 있다.

#### 1.6 DELETE

- `DELETE` 요청은 서버에 해당 리소스를 삭제하기 위해 보내는 요청이다.

#### 1.7 OPTIONS

- `OPTIONS` 요청은 서버가 해당 URI에 대해서 어떤 `HTTP Method`를 지원하는지 확인하고자 할 때 보내는 요청이다.

---

### 2. HTTPS란

- `HTTPS`는 HTTP의 보안이 강화된 버전으로 SSL를 사용하여 서버와 클라이언트 사이의 데이터를 암호화하는 프로토콜이며 443 포트를 사용한다.

---

### 3. SSL (Secure Socket Layer) 란?

- `SSL 인증서`는 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서이다.
- 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 제공하고 클라이언트는 이 인증서가 신뢰할 수 있는 인증서인지 검증한다.
- `SSL 인증서`를 이용했을 때의 이점은 다음과 같다.

1. 통신 내용이 외부에 노출되는 것을 막을 수 있다.
2. 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 판단할 수 있다.
3. 통신 내용의 악의적인 변경을 방지할 수 있다.

---

### 4. 암호화 방식

#### 4.1 대칭키 방식

- `대칭키 방식`을 사용하는 암호화 방식에서는 송수신측이 암호화와 복호화를 하는 데 동일한 비밀키를 사용하는 방식이다.
- `대칭키 방식`의 단점으로는 송수신측이 통신에 사용할 비밀키를 직접 주고받지 않는 이상 중간에서 제 3자에 의해 탈취될 가능성이 있으며 이로 인해 데이터의 위변조가 가능하다는 점이다.

#### 4.2 공개키 방식

- `공개키 방식`에서는 데이터를 암호화하고 복호화하는데 두 개의 키를 사용해서 암호화하는 방식이다.
- <u>A키로 암호화하면 B키로 복호화할 수 있고 B키로 암호화하면 A키로 복호화할 수 있는 방식이다.</u>

- 이러한 두 개의 키 중 하나를 `비밀키(private key)` 나머지 하나를 `공개키(public key)`라고 하는데 <u>비밀키는 자신만 갖고 있고, 공개키는 타인에게 제공한다.</u>
- 즉, `공개키`가 유출되었다고 하더라도, 공개키로 암호화한 데이터는 `비밀키`를 알지 못하면 복호화하지 못하기 때문에 안전한 방법이라고 할 수 있다.

---

### 5. 전자서명 방식

- `공개키 방식`을 응용하여 `전자 서명`을 구현(?)할 수 있다.
- 먼저, 비밀키의 소유자는 비밀키를 이용해서 데이터를 암호화한 후에 공개키와 함께 암호화된 데이터를 전송한다.
- 이 정보를 획득한 사람은 전달받은 공개키를 이용해서 암호화된 데이터를 복호화한다.
- 이 과정에서 공개키가 유출된다면 데이터의 위변조가 될 위험이 있다. 그럼에도 불구하고 이러한 방식을 사용하는 이유는 이러한 과정이 데이터를 암호화하는 목적이 아니기 때문이다.
- 암호화된 데이터와 공개키를 전달받은 측에서 공개키를 통해 복호화를 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 `비밀키`에 의해서 암호화된 것이라는 것을 증명한다.
- <u> 즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주는 것이다.</u>

---

### 6. SSL 동작방식

- `SSL` 방식에서는 `대칭키와 공개키`방식을 혼합해서 사용한다.
- 그 이유는 `공개키 방식`은 데이터를 암호화, 복호화하는 과정에서 많은 리소스 자원을 소모하기 때문이다.
- 클라이언트와 서버가 주고 받는 데이터는 `대칭키 방식`으로 암호화하여 통신하고, 그 암호화된 데이터를 복호화할 때 필요한 `대칭키`를 `공개키 방식`으로 교환한다.
  - 실제 데이터 : 대칭키 방식
  - 대칭키 방식에서의 키 : 공개키 방식



#### 6.1 HandShaking

1. 클라이언트가 서버에 접속하는데 이 단계를 `Client Hello`라고 한다.
   - 클라이언트 측에서 생성한 랜덤 데이터를 서버로 전송한다.
   - 클라이언트가 지원하는 암호화 방식들에 대한 정보를 서버로 전송하여, 서버와 클라이언트 간의 암호화 방식을 통일한다.
2. 서버는 `Client Hello`에 대한 응답으로 `Server Hello`를 하게 된다.
   - 서버 측에서 생성한 랜덤 데이터를 클라이언트로 전송한다.
   - 클라이언트에서 전송한 암호화 방식들 중, 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전송한다.
   - 이로써 `클라이언트-서버`간의 암호화 방식이 통일된다.
   - 마지막으로 클라이언트에게 `인증서`를 전송한다.
3. 클라이언트는 서버가 보낸 `인증서`가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다.
   - 이 과정에서 `CA 리스트`에 해당 인증기관이 없다면 사용자에게 경고 메시지를 출력한다.
   - 해당 인증기관이 존재한다면, 해당 인증기관의 `공개키`를 가지고 인증서를 복호화하는데 이때 복호화가 성공한다면 CA의 `비밀키`로 데이터가 암호화된 것임을 알 수 있고 인증서를 전송한 서버를 신뢰할 수 있다고 판단한다.

4. 클라이언트는 `서버의 랜덤 데이터`와 `클라이언트의 랜덤 데이터`를 이용해서 `pre master secret` 이라는 키를 생성한다.
   - 이 키는 데이터를 암호화하기 위해서 사용될 것이다.
   - 이때 사용되는 방식은 `대칭키 방식`이므로 `pre master secret` 키는 절대로 노출되어서는 안된다.
5. 클라이언트가 생성한 `pre master secret`키를 서버에서 전송한 `공개키`를 활용하여 암호화하고, 이를 서버에 다시 전송한다.
6. 서버는 자신이 가지고 있는 `비밀키`를 사용해서 클라이언트가 보낸 `pre master secret`키를 복호화한다.
   - 이 과정을 통해 `클라이언트-서버`가 데이터를 암호화하는데 필요한 `대칭키`를 공유하게 된다.
7. `클라이언트-서버`는 일련의 과정을 통해 `pre master secret`을 `session key`로 변환하고 이것을 활용해 데이터를 암호화, 복호화한다.
8. `클라이언트-서버`는 HandShake 단계의 종료를 서로에게 알린다.



#### 6.2 Session

- `세션` 과정에서는 `클라이언트-서버`가 서로 데이터를 주고 받는 단계이다.
- 이 단계에서의 핵심은 데이터를 상대방에게 전송하기 전에 `sessiong key(대칭키)`를 활용하여 암호화하고 데이터를 전송한다.
- 상대방도 `대칭키`를 알고 있기 때문에 데이터를 복호화할 수 있다.



#### 6.3 Session 종료

- 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.
- 이 때 통신에서 사용한 `session key`를 폐기한다.



![](../자료/SSL동작과정.PNG)

