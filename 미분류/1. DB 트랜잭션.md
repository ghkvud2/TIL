### 1. 트랜잭션(Transaction) 이란?

- `트랜잭션`은 DB의 상태를 변경하는 하나의 논리적인 기능을 수행하기 위한 작업의 단위이다.



### 2. 트랜잭션의 성질 (ACID)

#### 1. 원자성 (Atomicity)

- `트랜잭션`의 연산은 DB에 모두 반영되거나 전혀 반영되지 않아야한다.
- `트랜잭션`내의 모든 명령은 반드시 완벽히 수행되어야 하며 어느 하나라도 오류가 발생하면 `트랜잭션` 전부가 `롤백`되어야 한다.

#### 2. 일관성 (Consistency)

- `트랜잭션`이 성공적으로 완료되면 언제나 일관성있는 DB의 상태로 유지되야 한다.
- 즉, `트랜잭션` 수행 전후의 DB의 상태는 각각의 일관성이 보장되는 서로 다른 상태가 된다.
- 예를 들어, `자금 이체` 과정에서 두 계좌의 잔고의 합은 이체 전후가 같아야 한다.

#### 3. 격리성 (Isolation)

- 여러 `트랜잭션`이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.
- `격리성`을 보장할 수 있는 가장 쉬운 방법은 모든 `트랜잭션`을 순차적으로 수행하는 것이지만 성능 향상을 위해 병렬적으로 수행하는 것이 좋다.

#### 4. 지속성 (Durability)

- `트랜잭션`이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 보전되어야 한다.

---

### 3. 트랜잭션 격리 수준 (Isolation Level)

- `트랜잭션`에서 일관성이 없는 데이터를 허용할 수 있는 수준이다.
- `Locking`이라는 개념은 트랜잭션이 DB를 다루는 동안 다른 트랜잭션의 관여하지 못하게 막는 것이다.
- 그러나, 무조건적으로 `Locking` 범위를 늘려나가면 `동시성` 수준이 떨어지게 되므로 효율성에 문제가 있다.
- 그렇다고 `Locking` 범위를 좁혀버리면 `정합성`에 문제가 발생할 수 있다.

#### 낮은 격리 수준에서 발생할 수 있는 현상

#### 1. Dirty Read

- 다른 트랜잭션에 의해서 수정되었지만 아직 `커밋`되지 않은 데이터를 읽는 것을 말한다.
- 변경 후 커밋되지 않은 데이터를 읽었을 때 변경한 트랜잭션이 최종적으로 `롤백`된다면 그 값을 읽은 트랜잭션은 비일관된 상태에 놓이게 된다.

#### 2. Non-Repeatable Read

- 한 `트랜잭션` 내에서 같은 쿼리를 두 번 수행하였는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다.

#### 3. Phantom Read

- 한 `트랜잭션` 내에서 같은 쿼리를 두 번 수행하였는데 첫 번째 쿼리 결과에 없던 레코드가 두 번째 쿼리에서 나타나는 현상을 말한다.

---

### 4. 트랜잭션 격리 수준의 종류

#### 1. Read Uncommitted

- SELECT 문장이 수행되는 동안 해당 테이블에 `shared lock`이 걸리지 않는 수준이다.
- 즉, 다른 `트랜잭션`에서 `커밋`되지 않은 데이터를 읽어올 수 있는 level이다.

#### 2. Read Commited

- `트랜잭션`이 `커밋`되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용함으로써 `Dirty Read` 문제를 예방하는 level이다.
- 그러나, `Non-Repeatable Read와 Phantom Read` 현상은 막지 못한다.
  - 왜? `INSERT 나 UPDATE` 이후에 `커밋`을 했을 경우가 있으므로....
- 또한, 트랜잭션이 수행되는 동안에는 각 레코드에 대한 `locking`을 걸기 때문에 다른 트랜잭션이 레코드에 대한 `수정 및 삭제, 읽기` 연산을 수행할 수 없다.

#### 3. Repeatable Read

- `트랜잭션` 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리 결과에 있는 레코드의 값이 `변경되거나 삭제되지 않도록`하는 level이다.
- 즉, `트랜잭션` 범위내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
- 또한, 트랜잭션이 수행되는 동안에는 각 레코드에 대한 `locking`을 걸기 때문에 다른 트랜잭션이 레코드에 대한 `수정 및 삭제, 읽기` 연산을 수행할 수 없다.
- 그러나, 새로운 레코드가 나타날 수 있는 `Phantom Read` 현상은 막지 못한다.

**MySQL에서의 Repeatable Read**

- `Repeatable Read` 수준에서는 `Phantom Read` 현상이 발생하지만, MySQL에서는 그렇지 않을 수 있다.
- MySQL은 SELECT 쿼리를 수행할 때 해당 테이블에 `locking`을 걸지 않고, `snapshot`을 생성하고 거기서 데이터를 읽어온다.
- 이로인해 매번 SELECT 쿼리를 수행할 때 마다 최초에 생성했던 `snapshot`으로 부터 데이터를 읽어오기 때문에 `phantom read` 현상이 발생하지 않을 수 있다.
- **그러나**, 다른 트랜잭션에서 수행한 레코드에 대해서 `UPDATE, DELETE`의 결과는 출력될 수 있다.

#### 4. Serializable Read

- 동시성보다는 안전성을 중요시하는 level이다.

-  즉, 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않는다. 

![]( http://www.dbguide.net/publishing/img/knowledge/SQL_279.jpg )