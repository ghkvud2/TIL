### 1. 배열

#### 1-1. 데이터가 정렬되지 않은 상태일 때

1. 검색
   - 배열의 처음부터 끝까지 모두 확인해야 하므로  O(N)만큼의 시간이 걸린다.
2. 저장
   - 배열의 맨 마지막에 데이터를 저장하면 되기 때문에 O(1)만큼의 시간이 걸린다.
3. 삭제
   - 삭제할 데이터를 찾는데 걸리는 시간은 O(N)이고, 정렬이 필요없는 상태이므로 맨 뒤에 있는 데이터를 해당 자리로 옮기는데 O(1)만큼의 시간이 걸린다.

#### 1-2. 데이터가 정렬된 상태일 때

 	1. 검색
     - 이진 탐색을 사용하여 O(logN)만큼의 시간이 걸린다.
	2. 저장
    - 데이터가 저장할 위치가 배열의 맨 앞이라면, 모든 데이터들을 한칸씩 뒤로 미뤄야 하므로 O(N)만큼의 시간이 걸린다.
	3. 삭제
    - 맨 앞의 데이터를 삭제해야한다면, 모든 데이터들을 한칸씩 앞으로 당겨야 하므로 O(N)만큼의 시간이 걸린다.



### 2. 연결리스트

#### 2-1. 데이터가 정렬되지 않은 상태일 때

1. 검색
   - 배열의 처음부터 끝까지 모두 확인해야 하므로  O(N)만큼의 시간이 걸린다.

2. 저장
   - 연결리스트의 head 혹은 tail에 데이터를 저장하면 되기 때문에 O(1)만큼의 시간이 걸린다.
3. 삭제
   - 삭제할 데이터를 찾는데 걸리는 시간은 O(N)이고, 그 데이터를 삭제하는 시간은 O(1)만큼 걸린다.

#### 2-2. 데이터가 정렬된 상태일 때

1. 검색
   - 배열의 처음부터 끝까지 모두 확인해야 하므로  O(N)만큼의 시간이 걸린다.
2. 저장
   - 저장할 위치를 찾는데 걸리는 시간은 O(N)이고, 데이터를 저장하는데 걸리는 시간은 O(1)이다.
3. 삭제
   - 삭제할 데이터를 찾는데 걸리는 시간은 O(N)이고, 그 데이터를 삭제하는 시간은 O(1)만큼 걸린다.

|            | 정렬 여부 | 검색    | 저장        | 삭제        |
| ---------- | --------- | ------- | ----------- | ----------- |
| 배열       | O         | O(logN) | O(N)        | O(N)        |
|            | X         | O(N)    | O(1)        | O(N) + O(1) |
| 연결리스트 | O         | O(N)    | O(N) + O(1) | O(N) + O(1) |
|            | X         | O(N)    | O(1)        | O(N) + O(1) |



### 3. 배열 VS 연결리스트

#### 3-1. 배열

- 배열은 인덱스 기반으로 데이터에 접근하기 때문에 O(1)의 시간복잡도를 가진다.
- 데이터를 맨 끝에 추가하는 경우에는 O(1)만큼의 시간 복잡도를 가지고, 데이터를 중간에 추가하는 경우에는 데이터를 앞 뒤로 미뤄야하기 때문에 O(N)만큼의 시간 복잡도를 가진다.
- 배열의 경우 물리적 주소 또한 순차적으로 저장되어 있다.

#### 3-2. 연결리스트

- 연결리스트는 데이터를 찾기 위해서는 전체를 확인해야하기 때문에 검색 시간이 배열보다 오래걸리지만, 데이터를 저장하거나 삭제하는 경우에는 O(1)만큼의 시간이 걸린다.
- 연결리스트의 각 노드들은 동적으로 할당되기 때문에 물리적 주소가 순차적으로 저장되지 않는다.

