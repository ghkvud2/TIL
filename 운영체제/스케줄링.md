### CPU 스케줄링

- `Ready Queue` 안에 여러 프로세스가 있을 때 다음에 CPU를 선점할 프로세스를 선정하는 것을 CPU 스케줄링이라고 한다.



### 1. Scheduling Criteria

1. CPU Utilization (CPU 이용률)
   - CPU가 놀지 않고 얼마나 많이 사용되는가의 척도이다. (0~100%)
2. Throughput (처리량)
   - 단위시간당 CPU가 처리하는 일의 양이다.
   - 주어진 시간동안 몇 개의 프로세스를 수행했는지를 나타낸다.
3. Turnaround Time
   - 특정 프로세스가 작업을 끝내는 데 걸리는 총 시간이다.
   - 프로세스가 `Ready`상태에서 `Terminated` 상태가 될 때 까지의 총 시간이다.
4. Waiting Time (대기시간)
   - `Ready Queue`에서 CPU를 선점하기 위해서 기다린 총 시간이다.
   - `I/O`의 대기시간과는 상관없다.
5. Response Time
   - 대화형으로 동작할 때 응답받는 시간이다.
   - 

### 2. 선점 스케줄링

- 프로세스 `P1`이 CPU를 점유하여 작업을 진행 중에 있더라도 다른 프로세스 `P2`가 CPU를 선점할 수 있도록 하는 스케줄링이다.

#### 2.1 SRT (Shortest Remaining Time)

- 남아있는 처리시간이 짧은 순서대로 프로세스를 수행하되, 처리 시간이 더 짧은 프로세스가 `Ready Queue`에 들어올 경우 그 프로세스가 CPU에 할당된다.
- `SJF` 스케줄링과 비슷하나 `SRT`는 선점형이라고 할 수 있다.

| Process | Arrival Time | Burst Time (msec) |
| ------- | ------------ | ----------------- |
| P1      | 0            | 8                 |
| P2      | 1            | 4                 |
| P3      | 2            | 9                 |
| P4      | 3            | 5                 |

- SRT 방식 : (9 + 0 + 15 + 2) / 4 =6.5 msec
- SJF 방식 : 7.75 msec



#### 2.2 RR (Round Robin)

- 프로세스는 같은 크기의 시간 할당량 (Time Slice)를 할당받고 FCFS에 의해서 처리하는 방식을 말한다.
- 현재 처리되고 있는 `P1`프로세스가 시간 할당량을 모두 소모하면 다음 프로세스인 `P2`가 CPU를 선점한다.
- 시간 할당량이 너무 크면 `FCFS`와 다를바가 없고, 너무 작으면 `오버헤드`가 커진다.

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 24                |
| P2      | 3                 |
| P3      | 3                 |

- 시간 할당량을 4msec 라고 할 때, `평균 대기시간`은 (6 + 4 + 7) / 5 = 5.66 msec이다.

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 6                 |
| P2      | 3                 |
| P3      | 1                 |
| P4      | 7                 |

- 시간 할당량 = 1 msec 일 때, `평균 반환시간`은 (15 + 9 + 3 + 17 ) / 4 = 11 msec이다.
- 시간 할당량 = 5 msec 일 때, `평균 반환시간`은 (15 + 8 + 9 + 17) / 4 = 12.25 msec이다.



#### 2.3 Multilevel Queue

- 프로세스는 성격에 따라 시스템, 대화형, 배치 등으로 그룹화할 수 있다.
- 이러한 그룹화된 프로세스들은 그 우선순위가 다를 수 있기 때문에 하나의 `Ready Queue`에 저장하는 것이 비효율적일 수 있다.
- 그렇기 때문에, 프로세스의 성격에 따라 저장되는 `Ready Queue`를 여러 개 두는 방식이다.
- 각각의 `Ready Queue`들 간에는 절대적인 우선순위가 존재한다.
- 예를 들어, `시스템 프로세스` 의 `Ready Queue`는 우선순위가 가장 높고, `대화형 프로세스`의 우선순위를 그 다음으로 둘 수 있다.

![](https://postfiles.pstatic.net/MjAxOTA0MjJfMTMy/MDAxNTU1OTA1ODcyMzY3.kthgGfKSENWCOd98KGRjzqL-3qnDOsGsrmAYoZ3n5V0g.yGitHPnlBcJL-8QbzJ1-XQBkk7339zVMtUXrrGcNVN0g.PNG.jhnyang/image.png?type=w773)

- 위 그림처럼, `Ready Queue`를 여러 개 두고, 각각의 큐들 마다 시간 할당량을 다르게 주어 프로세스를 처리한다.
- 당연히, `시스템 프로세스` 처럼 우선순위가 높은 큐에 많은 시간할당량을 할당한다.
- 또한, 각각의 큐는 각각의 독립적인 `CPU 스케줄링`을 사용할 수 있다.



#### 2.4 Multilevel Feedback Queue

- 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다.

- 마찬가지로, 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위를 가진 큐로 이동되어 `기아 현상`을 예방한다.

  

### 3. 비선점 스케줄링

- 프로세스 `P1`이 CPU를 점유하면 그 작업이 끝날 때 까지 다른 프로세스가 CPU를 점유할 수 없는 스케줄링이다.



#### 3.1 FCFS (First Come First Service)

- `Ready Queue`에 들어온 순서대로 처리하는 방식이다.
- 간단하면서도 공평한 방법이다.
- `대기 시간`을 성능 평가의 척도로 삼을 경우, 좋지 않은 방법이라고 할 수 있다.
- 호위 효과 (convoy effect)
  - 처리시간이 긴 프로세스를 기준으로 다른 프로세스들이 뒤에 줄을 서게 되는 현상을 말한다.

| Process | Burst Time (msec) |
| ------- | :---------------- |
| P1      | 24                |
| P2      | 3                 |
| P3      | 3                 |

- FCFS를 적용하면 평균 대기시간은 (0 + 24 + 27) / 3 = 17 msec 이다.

- 그러나, P2 -> P3 -> P1 순서대로 처리하면 (0 + 3 + 6) / 3 = 9 msec 이다.

  

#### 3.2 SJF (Shortest Job First)

- 처리시간이 짧은 작업부터 먼저 처리하는 스케줄링 방식이다.
- `SJF`는 대기시간을 줄이는 방법에서는 가장 좋은 방법이다.

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 6                 |
| P2      | 8                 |
| P3      | 7                 |
| P4      | 3                 |

- 처리를 P4 -> P1 -> P3 -> P2 순서대로 하면, 평균 대기 시간은 (0 + 3 + 9 + 16) / 4 = 7 msec 이다.
- `SJF`의 가장 큰 단점으로는 현실적이지 않다는 것이다. 임의의 프로세스 P에 대한 **예상 처리 시간을 계산하는 것 자체가 어렵기 때문이다.**
- **SRT 스케줄링과 비교하여 살펴본다.**



#### 3.3 Priority

- 우선순위가 높은 프로세스를 먼저 처리하는 방식이다.

- 우선순위를 정하는 방식은 내부적인 요소와 외부적인 요소를 가지고 정할 수 있다.

  | Process | Burst Time (msec) | Priority |
  | ------- | ----------------- | -------- |
  | P1      | 10                | 3        |
  | P2      | 1                 | 1        |
  | P3      | 2                 | 4        |
  | P4      | 1                 | 5        |
  | P5      | 5                 | 2        |

- 평균 대기시간은 (6 + 0 + 16 + 18 + 1) / 5 = 8.2 msec 이다.



#### 기아 (Starvation) 현상이란?

- 우선순위가 낮은 프로세스 `P`가 있을 때, `Ready Queue`에 프로세스 P보다 높은 우선순위의 프로세스가 계속해서 도착한다면, 프로세스 P는 영원히 CPU를 선점하지 못하는 상황이 발생한다.

- `기아`현상을 해결하기 위해서 일정시간이 지나면, 프로세스 P에 우선순위를 점차적으로 높여주어 해결할 수 있다. 이 기법을 **`에이징`**이라고 한다.

  