### 1. 가상메모리

- 가상 메모리라는 것은 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
- 이 기법의 장점은 사용자 프로세스가 메모리 용량보다 크더라도 실행이 가능하도록 한다는 것이다.
- 물론, `동적 로딩` 방법을 사용하면 프로세스 전체를 메모리에 올리지 않아도 되기는 하지만 이 방법은 프로그래머에게 특별한 주의와 추가적인 작업을 요구한다.

---

### 2. 배경

- 프로그램에는 잘 발생하지 않는 오류를 처리하는 코드가 존재한다. 이러한 오류들은 실질적으로 발생하는 빈도수가 적기 때문에, 이 코드들은 거의 실행되지 않는다.
- 또한, 전체 프로그램이 메모리에 올라가 있는 상태라고 하더라도, 프로세스의 모든 부분이 동시에 요구되지 않을 수 있다.
- 이러한 관점에서 봤을 때, 프로그램의 일부분만 메모리에 올려놓고 실행할 수 있다면 효율성을 높일 수 있다.

---

### 3. 요구 페이징 (Demand Pagin)

- 프로그램 실행을 시작 할 때, 프로그램의 전부를 물리 메모리에 적재하는 방법은 비효율적이다.
- 그러므로, 해당 프로그램에서 실제 필요로 하는 부분만을 물리 메모리에 적재하는 기법을 `요구 페이징`이라고 한다.
- 가상 메모리에서는 `페이지`들이 실행 과정에서 실제로 필요할 때 물리 메모리에 적재되므로 실행 과정 중에서 한번도 접근되지 않은 `페이지`는 물리 메모리에 적재되지 않는다.
- 프로세스는 보통 `예비 저장장치 (혹은 스왑 장치)`에 상주하고 있는데, 프로세스를 실행 할 때  물리 메모리에 적재된다.



#### 3-1. 기본 개념

- `스와핑` 개념에서 어떤 페이지가 물리 메모리에 적재되어 있는지 아닌지를 확인하기 위한 수단이 필요하다.
- 이를 위해서, `유효 비트(valid bit)` 를 사용하는데, `유효 비트`가 1로 설정되어 있으면 현재 페이지가 물리 메모리에 적재되었다는 뜻이고, `유효 비트`가 0으로 설정되어 있으면 물리 메모리에 존재하지 않고 `예비 저장장치`에 존재한다는 것을 뜻한다.



#### 3-2. 페이지 부재 (Page fault)

- 프로세스가 메모리에 올라와 있지 않는 페이지를 접근하려고 하는 것을 `페이지 부재`라고 한다.

<img src="../자료/페이지부재처리과정.png" style="zoom:60%;" />

1. CPU가 `load M`이라는 명령어를 수행한다고 가정하자. CPU가 발생시킨 논리주소에 의해서 해당 페이지가 존재하는 지 확인한다.
2. 페이징 하드웨어는  `유효 비트`를 확인하여 무효한 참조라면 해당 프로세스를 종료시키고, 유효한 참조인데 물리 메모리에 적재되지 않은 상태라면 운영체제에게 트랩을 건다.
3. 운영체제는 `예비 저장장치`에서 해당 페이지가 존재하는지 확인을 한다.
4. 물리 메모리에서 `자유 프레임(Free Frame)`을 찾아 해당 페이지를 적재시킨다.
5. 페이지 테이블의 `유효 비트`를 갱신한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다.



- 물리 메모리에 페이지가 하나도 올라오지 않은 극단적인 상황에서도 프로세스를 실행할 수 있다. 
- 이 과정에서는 프로세스가 필요로 하는 모든 페이지가 적재될 때 까지 `페이지 부재`가 발생하게 된다.
- 필요한 페이지가 모두 적재되고 나면, 그 다음부터는 `페이지 부재`가 발생하지 않는데, 이것을 `순수 요구 페이징 (Pure Demand Pagin)` 이라고 한다.



#### 3-3. 요구 페이징의 성능

1. P : 페이지 부재가 발생할 확률
2. T<sub>m</sub> : 메모리 접근시간
3. T<sub>p</sub> : 페이지 부재 처리시간
4. T<sub>eff</sub> = (1-P) * T<sub>m</sub> + P * T<sub>p</sub> 으로 나타낼 수 있다.

- `페이지 부재`를 처리하는 데 걸리는 시간은 아래와 같다.
  - 디스크의 헤더가 데이터가 저장된 위치로 옮기는 시간 (seek time)
  - 디스크가 한바퀴 도는 시간 (rotational time)
  - 디스크로부터 데이터를 읽는 시간 (transfer time)

---

### 4. 페이지 교체 (Page Replacement)

- 만약 빈 프레임이 없다면, 현재 사용되고 있지 않는 프레임을 찾아서 그것을 비워버린다.
- 그 프레임의 내용을 `스왑 장치` 에 쓰고 그 페이지가 메모리에 더 이상 존재하지 않는다는 것을 알리기 위해 `페이지 테이블`을 갱신한다.



#### 4-1. 페이지 교체 과정

![](../자료/페이지교체.png)

1. 디스크에서 필요한 페이지의 위치를 알아낸다.
2. 빈 페이지 프레임을 찾는다
   - 빈 프레임이 있다면 사용한다.
   - 빈 프레임이 없다면
     - 희생될 프레임을 선정하기 위하여 `페이지 교체 알고리즘`을 가동한다.
     - 희생 페이지를 디스크에 기록하고 (변경된 사항을 다시 write) 관련된 페이지 테이블을 수정한다.
3. 새로운 페이지를 프레임에 할당하고, 페이지 테이블을 갱신한다.
4. `페이지 부재`가 발생한 지점에서부터 프로세스를 계속 실행한다.



- 위의 과정에서 디스크에 접근하는 횟수가 두번임을 알 수 있다.
- 이러한 오버헤드를 피하기 위해 `변경 비트(modify bit or dirty bit)`라고 하는 비트를 사용해서 감소시킬 수 있다. CPU내의 페이지가 수정이 발생하면 `변경 비트`를 설정한다.
- `희생 페이지`를 선택한 뒤, `예비 저장장치`로 내보내기 전에 `변경 비트`를 확인하여 수정이 발생했으면 디스크에 다시 저장한다.