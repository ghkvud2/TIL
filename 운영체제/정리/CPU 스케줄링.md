## 1. CPU 스케줄링

- 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해서 항상 실행 중인 프로세스를 가지게하는데 있다.
- 예를 들어, 하나의 프로세스가 입출력 처리가 완료되기를 기다리는 상황에서 CPU를 어떠한 작업도 수행하지 못한다. 
- 즉, 어떤 프로세스가 대기해야 하는 경우, 그 프로세스에 할당된 자원을 빼앗아 다른 새로운 프로세스에게 할당하는 것이다.



### 1-1. CPU 스케줄러

- CPU가 유휴 상태가 될 때 마다, 운영체제는 `준비 완료 큐`에 있는 프로세스를 선택하여 실행해야한다. 이 과정은, `단기 스케줄러`에 의해 수행된다.

- `준비 완료 큐`에 있는 데이터들은 일반적으로 프로세스의 PCB들이다.



### 1-2. 스케줄링 기준

1. CPU Utilization (CPU 이용률)
   - CPU가 놀지 않고 얼마나 많이 사용되는가의 척도이다. (0~100%)
2. Throughput (처리량)
   - 단위시간당 CPU가 처리하는 일의 양이다.
   - 주어진 시간동안 몇 개의 프로세스를 수행했는지를 나타낸다.
3. Turnaround Time
   - 특정 프로세스가 작업을 끝내는 데 걸리는 총 시간이다.
   - 프로세스가 `Ready`상태에서 `Terminated` 상태가 될 때 까지의 총 시간이다.
4. Waiting Time (대기시간)
   - `Ready Queue`에서 CPU를 선점하기 위해서 기다린 총 시간이다.
   - `I/O`의 대기시간과는 상관없다.
5. Response Time
   - 대화식 시스템에서 요청 후, 응답이 오기 시작할때 까지의 시간이다.



## 2. 스케줄링 종류

- 스케줄링 종류는 크게 `선점형 스케줄링`과 `비선점형 스케줄링`으로 나뉜다.
- `선점형 스케줄링`은 CPU가 프로세스에 할당되어 실행되고 있는 도중, 새로운 프로세스가 CPU에 할당될 수 있는 방식이다.
- `비선점형 스케줄링`은 프로세스가 작업을 끝마칠 때 까지, 다른 프로세스가 CPU를 선점할 수 없는 방식이다.



### 2-1. 비선점형 스케줄링

#### 1. FCFS 스케줄링 (First Come, First Service)

- `준비 완료 큐`에 먼저 도착한 프로세스가 CPU를 먼저 할당받는 방식이다.
- 모든 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 `호위 효과 (convoy effect)` 라고한다.
- 이 효과는 짧은 처리시간을 가진 프로세스들이 먼저 처리되도록 허용될 때 보다 CPU와 장치 이용률이 저하되는 단점이 있다.
- `FCFS` 방식에서 평균 대기 시간은 일반적으로 최소가 아니다.

| Process | Burst Time (msec) |
| ------- | :---------------- |
| P1      | 24                |
| P2      | 3                 |
| P3      | 3                 |

- FCFS를 적용하면 평균 대기시간은 (0 + 24 + 27) / 3 = 17 msec 이다.
- 그러나, P2 -> P3 -> P1 순서대로 처리하면 (0 + 3 + 6) / 3 = 3 msec 이다.



#### 2. SJF 스케줄링 (Shortest-Job-First)

- `CPU` 버스트가 가장 작은 프로세스부터 CPU를 선점할 수 있도록 하는 방식이다.
- `SJF` 방식은 최소의 평균 대기 시간을 보장한다. 

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 6                 |
| P2      | 8                 |
| P3      | 7                 |
| P4      | 3                 |

- 처리를 P4 -> P1 -> P3 -> P2 순서대로 하면, 평균 대기 시간은 (0 + 3 + 9 + 16) / 4 = 7 msec 이다.
- `SJF`의 가장 큰 단점으로는 현실적이지 않다는 것이다. 임의의 프로세스 P에 대한 **예상 처리 시간을 계산하는 것 자체가 어렵기 때문이다.**
- **SRT 스케줄링과 비교하여 살펴본다.**



#### 3. Priority

- 우선순위가 높은 프로세스를 먼저 처리하는 방식이다.

- 우선순위를 정하는 방식은 내부적인 요소와 외부적인 요소를 가지고 정할 수 있다.

  | Process | Burst Time (msec) | Priority |
  | ------- | ----------------- | -------- |
  | P1      | 10                | 3        |
  | P2      | 1                 | 1        |
  | P3      | 2                 | 4        |
  | P4      | 1                 | 5        |
  | P5      | 5                 | 2        |

- 평균 대기시간은 (6 + 0 + 16 + 18 + 1) / 5 = 8.2 msec 이다.

#### 기아 (Starvation) 현상이란?

- 우선순위가 낮은 프로세스 `P`가 있을 때, `Ready Queue`에 프로세스 P보다 높은 우선순위의 프로세스가 계속해서 도착한다면, 프로세스 P는 영원히 CPU를 선점하지 못하는 상황이 발생한다.
- `기아`현상을 해결하기 위해서 일정시간이 지나면, 프로세스 P에 우선순위를 점차적으로 높여주어 해결할 수 있다. 이 기법을 **`에이징`**이라고 한다.



### 2-2. 선점형 스케줄링

#### 1. SRT (Shortest Remaining Time)

- 남아있는 처리시간이 짧은 순서대로 프로세스를 수행하되, 처리 시간이 더 짧은 프로세스가 `Ready Queue`에 들어올 경우 그 프로세스가 CPU에 할당된다.
- `SJF` 스케줄링과 비슷하나 `SRT`는 선점형이라고 할 수 있다.

| Process | Arrival Time | Burst Time (msec) |
| ------- | ------------ | ----------------- |
| P1      | 0            | 8                 |
| P2      | 1            | 4                 |
| P3      | 2            | 9                 |
| P4      | 3            | 5                 |

- SRT 방식 : (9 + 0 + 15 + 2) / 4 =6.5 msec
- SJF 방식 : 7.75 msec



#### 2. RR (Round Robin)

- 프로세스는 같은 크기의 시간 할당량 (Time Slice)를 할당받고 FCFS에 의해서 처리하는 방식을 말한다.
- 현재 처리되고 있는 `P1`프로세스가 시간 할당량을 모두 소모하면 다음 프로세스인 `P2`가 CPU를 선점한다.
- 시간 할당량이 너무 크면 `FCFS`와 다를바가 없고, 너무 작으면 `오버헤드`가 커진다.

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 24                |
| P2      | 3                 |
| P3      | 3                 |

- 시간 할당량을 4msec 라고 할 때, `평균 대기시간`은 (6 + 4 + 7) / 5 = 5.66 msec이다.

| Process | Burst Time (msec) |
| ------- | ----------------- |
| P1      | 6                 |
| P2      | 3                 |
| P3      | 1                 |
| P4      | 7                 |

- 시간 할당량 = 1 msec 일 때, `평균 반환시간`은 (15 + 9 + 3 + 17 ) / 4 = 11 msec이다.
- 시간 할당량 = 5 msec 일 때, `평균 반환시간`은 (15 + 8 + 9 + 17) / 4 = 12.25 msec이다.

#### 3. 다단계 큐 스케줄링 (Multilevel Queue)

- 프로세스는 성격에 따라 시스템, 대화형, 배치 등으로 그룹화할 수 있다.
- 이러한 그룹화된 프로세스들은 그 우선순위가 다를 수 있기 때문에 하나의 `Ready Queue`에 저장하는 것이 비효율적일 수 있다.
- 그렇기 때문에, 프로세스의 성격에 따라 저장되는 `Ready Queue`를 여러 개 두는 방식이다.
- 각각의 `Ready Queue`들 간에는 절대적인 우선순위가 존재한다.
- 예를 들어, `시스템 프로세스` 의 `Ready Queue`는 우선순위가 가장 높고, `대화형 프로세스`의 우선순위를 그 다음으로 둘 수 있다.

![](https://postfiles.pstatic.net/MjAxOTA0MjJfMTMy/MDAxNTU1OTA1ODcyMzY3.kthgGfKSENWCOd98KGRjzqL-3qnDOsGsrmAYoZ3n5V0g.yGitHPnlBcJL-8QbzJ1-XQBkk7339zVMtUXrrGcNVN0g.PNG.jhnyang/image.png?type=w773)

- 위 그림처럼, `Ready Queue`를 여러 개 두고, 각각의 큐들 마다 시간 할당량을 다르게 주어 프로세스를 처리한다.
- 당연히, `시스템 프로세스` 처럼 우선순위가 높은 큐에 많은 시간할당량을 할당한다.
- 또한, 각각의 큐는 각각의 독립적인 `CPU 스케줄링`을 사용할 수 있다.



#### 4. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue)

- 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다.
- 마찬가지로, 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위를 가진 큐로 이동되어 `기아 현상`을 예방한다.