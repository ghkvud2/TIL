## 메모리 관리 전략

#### 용어 확인

1. Block : 보조기억장치와 주기억장치 사이의 데이터 전송 단위 (1~4KB)
2. Word : 주기억장치와 CPU 레지스터 사이의 데이터 전송 단위 (16~64bit)



### 1. 주소의 할당 (Address Binding)

- 프로그램은 실행 파일 형태로 디스크에 저장되어 있는데, 이 프로그램이 실행되기 위해서는 메인 메모리에 적재되어 `프로세스`가 되어야 한다.
- 디스크에서 메인 메모리로 들어오기를 기다리고 있는 프로세스들의 집합을 이른바 `입력 큐(input queue)`라고 부른다.
- 또한, 프로그램의 논리 주소를 실제 메모리의 물리 주소로 매핑하는 작업을 `주소의 할당`이라고 할 수 있다.

![](../자료/주소바인딩.PNG)



#### 1-1. 컴파일 시간 바인딩 (Compile Time Binding)

- 프로세스가 컴파일 시점에 메모리에 적재될 위치를 미리 알 수 있는 경우이다.
- 예를 들어, 프로세스가 R번지로부터 시작한다는 것을 미리 알 수 있으면 번역할 코드를 그 위치에서 시작해 나간다.

#### 1-2. 적재 시간 바인딩 (Load Time Binding)

- 메모리 적재 위치를 컴파일 시점에 모르면, 우선 대체 가능한 상대주소를 생성한다.
- `적재 시점`에 시작 주소를 반영하여 주소를 재설정하는 방법이다.
- 예를 들어, 상대 주소를 `R + 100`이라고 지정해 놓은 후 실제 적재될 메모리 시작 주소가 100이라고 하면, `100 + 100` 으로 변환되는 것이다.

#### 1-3. 실행 시간 바인딩 (Execution Time Binding)

- `주소 할당`을 실행 시간까지 연기하는 방법이다.
- 즉, 프로세스의 상태가 `Ready -> Running` 상태가 될 때 물리 주소를 할당하는 것이다.
- 이 방법을 사용하기 위해서는 하드웨어인 MMU (Memory Management Unit)이 필요하다.

---

### 2. 메모리 할당 기법

#### 2-1. 최초 적합 (First - Fit)

- 첫 번째 사용 가능한 가용 공간을 할당한다. 만약, 첫 번째 사용 가능한 공간이 요구 공간보다 매우 클 경우 공간 활용률이 많이 낮아질 수 있다.
- 충분한 크기를 가진 첫 번째 Partition을 선택하기 때문에 다른 기법들과 비교해봤을 때 가장 빠른 기법으로 오버헤드가 가장 작다.

#### 2-2. 최적 적합 (Best - Fit)

- 사용 가능한 공간들 중에서 가장 작은 것을 택한다.
- 리스트가 크기 순으로 정렬되어 있지 않다면 전체 탐색을 요구한다.
- 크기가 큰 Partition을 유지하기에는 적합하지만, 작은 크기의 Partition이 많이 생긴다.

#### 2-3. 최악 적합 (Worst - Fit)

- 사용 가능한 공간들 중에서 가장 큰 것을 택한다.
- 이 방법 또한, 크기 순으로 정렬되어 있지 않다면 전체 탐색을 요구한다.
- 큰 크기의 Partition 확보가 어려울 수 있지만, 작은 Partition의 비율을 줄일 수 있다.

#### 2-4. 순차 최초 적합 (Next-Fit)

- 최초 적합 전략과 유사하지만, `State table`에서 마지막으로 탐색한 위치부터 탐색한다.
- 메모리 영역의 사용 빈도를 균등화할 수 있다.

---

### 3. 동적 적재 (Dynamic Loading)

- 메모리 공간을 보다 효율적으로 이용하기 위해서는 `동적 적재`를 해야한다.
- `동적 적재`에서 각 루틴 (함수 등)은 실제 호출되기 전까지는 메모리에 올라오지 않고 디스크에서 대기하고 있다.
- `메인` 프로그램이 메모리에 적재되어 실행되다가 루틴의 호출 시점에 `주소 할당`을 수행하여 각각의 루틴을 수행하는 방식이다.
- 이러한 방식은, `오류 처리`와 같이 간혹 발생하지만 많은 양의 코드를 필요로 하는 경우에 유용하다.

---

### 4. 스와핑 (Swapping)

- 프로세스가 실행되기 위해서는 메인 메모리에 적재되어 있어야 하지만 프로세스는 실행 중에 임시로 `예비 저장장치 (backup store)`로 보내졌다가 실행을 계속하기 위해 메모리로 돌아올 수 있다.
- `스와핑`이 발생하는 시점은 `ready`상태 에서와 `asleep` 상태에서 발생한다.

![](../자료/스왑.png)

- `예비 저장장치(backup store)` 의 크기는 모든 사용자의 메모리 이미지를 저장할 수 있을만큼 커야하며 이 메모리 이미지에 대한 직접 접근이 가능해야한다.
- `스와핑`은 메모리 혼잡 상태를 개선하거나, 가용 메모리보다 요청 메모리의 크기가 클 때 수행된다.

---

### 5. 연속 메모리 할당 (Contiguous Memory Allocation)

- 메모리는 일반적으로 운영체제를 위한 공간과 사용자 프로세스를 위한 것으로 나눌 수 있다.

- `연속 메모리 할당` 시스템에서는 각 프로세스는 다음 프로세스를 포함하는 메모리 영역과 연속된 하나의 메모리 영역을 차지하게 된다.

- **즉, 프로세스를 하나의 연속된 메모리 공간에 할당하는 정책이다.**

  

#### 5-1. 고정 분할 기법 (Fixed Partition Multiprogramming) - FPM

- 메모리를 고정된 크기로 미리 분할하는 방법이다.
- 각 분할 (partition) 마다 하나의 프로세스를 갖기 때문에 분할의 갯수를 다중 프로그래밍의 정도라고 부른다.
- 이 기법은 `단편화`가 발생하여 메모리 자원이 낭비될 수 있다.



#### 5-2. 가변 분할 기법 (Variable Partition Multiprogramming) - VPM

- 시스템이 부팅된 직후에는 운영체제가 차지하는 메모리 영역을 제외한 나머지 영역은 하나의  공간이다.
- 이때, 시스템에 들어오는 프로세스가 요구하는 메모리만큼만을 할당하는 기법이다.
- 프로세스가 요구하는 메모리만큼 할당하기 때문에 `내부 단편화`는 발생하지 않는다.

---

### 6. 메모리 단편화

- `메인 메모리`에서 메모리 공간이 작은 공간으로 나누어져 전체적으로는 충분한 가용 공간이 있지만, 사실상 프로세스에 할당 될 수 없는 것을 `메모리 단편화`라고 한다.

#### 6-1. 내부 단편화(Internal Fragmentation)이란?

- 프로세스에 메모리를 할당할 때, 프로세스가 필요로 하는 공간보다 더 많은 공간을 할당하여 메모리가 낭비되는 현상을 `내부 단편화`라고 한다.

#### 6-2. 외부 단편화(External Fragmentation)이란?

- 메모리 중간 중간에 비어있는 공간은 충분하지만, 메모리가 연속되지 않아 프로세스가 메모리에 적재될 수 없는 상태를 `외부 단편화`라고 한다.

---

### 7. 메모리 단편화 해결방법

#### 7-1. 공간 통합 (Coalescing holes)

- 단편화로 인해 분산된 메모리 공간을 인접해있는 메모리 공간끼리 통합시켜 더 큰 메모리 공간으로 합치는 기법이다.

#### 7-2. 메모리 압축 (Storage Compaction)

- 단편화로 인해 분산된 메모리 공간을 하나로 합치는 기법이다.
- 즉, 프로세스에 할당된 메모리 공간을 한 군데로 몰고, 가용 가능한 공간들은 다른 한 군데로 몰아서 큰 블록을 만드는 것이다.

- 단, `메모리 압축` 방식은 모든 프로세스를 재배치해야 하기 때문에 모든 프로세스의 작업이 중단되고, 많은 시스템 자원을 소비한다.