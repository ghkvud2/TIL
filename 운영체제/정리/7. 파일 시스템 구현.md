### 1. 디렉터리 구현

- 디렉터리 공간을 어떻게 할당하고 관리하는가는 파일 시스템의 효율, 성능과 신뢰성에 큰 영향을 미친다.
- 따라서 이러한 알고리즘에 연관되어 있는 문제점들을 이해할 필요가 있다.



#### 1.1 선형 리스트 (Linear List)

- 디렉터리를 가장 간단하게 구현하는 방법은 `파일 이름`과 `데이터 블록`에 대한 포인터들의 `선형 리스트`를 사용하는 것이다.
- 먼저, 디렉터리를 탐색하여 같은 이름을 가진 파일이 존재하지 않는다는 것을 확인하고 연결 리스트의 끝 부분에 새로운 항목을 추가한다.
- 삭제할 경우, 해당 디렉토리를 찾아 메모리 공간을 해제한다.
- `선형 리스트`로 된 디렉터리의 가장 큰 단점은 파일을 찾기 위해 선형 탐색을 해야한다는 점이다.
- 이 문제를 해결하기 위해 `캐시 하드웨어`를 사용하거나 `B-트리`를 사용할 수 있다.



#### 1.2 해시 테이블

- 파일 이름으로부터 `해시 값`을 얻어내고 그것을 포인터로 활용하여 직접 리스트에 접근함으로써 디렉터리를 구현할 수 있다.
- `해시 테이블`의 문제점은 고정된 크기를 갖는다는 점과 해시 테이블의 크기에 따라 `충돌 확률`이 정해지는 것이다.
- 한 마디로 `해시 알고리즘`과 똑같이 구현하면 된다.

---

### 2. 파일 할당 방법 (Allocation Methods)

- 파일들을 어떻게 디스크 공간에 배치해야 디스크 공간을 효율적으로 사용할 수 있고, 파일들에 빨리 접근할 수 있는지가 중요하다.
- 디스크 공간을 할당하기 위해서는 세 가지 주된 방법이 있는데 그 방법은 `연속 할당, 연결 할당, 인덱스 할당`기법이 널리 사용된다.



#### 2.1 연속 할당 (Contiguous Allocation)

- `연속 할당`은 각 파일이 디스크 내에서 연속적인 공간을 차지하도록 한다.
- 각 파일들은 디스크 상에서 선형 순서로 저장되기 때문에 디스크 헤드의 이동을 최소화할 수 있으므로 탐색 시간이 최소화 된다.
- `연속 할당` 기법은 파일을 `순차 접근과 직접 접근` 두 가지를 모두 지원한다.
  - 순차적으로 접근하려면 가장 최근에 참조된 주소를 기억하고 있다가 다음 블록을 읽어 들이면 된다.
  - 직접 접근하려면 파일의 시작 블록인 b 에서부터 i만큼 떨어진 `b+i` 블록으로 바로 이동하여 블록을 읽어들이면 된다.

#### 연속 할당 기법의 단점

- `외부 단편화`가 발생한다.
  - 파일이 할당되고 반납됨에 따라 여유 디스크 공간이 자그만 조각으로 나뉘기 때문에 `외부 단편화`가 발생한다.
- 새로운 파일을 위해서 얼마나 많은 공간을 할당해야하는지 알 수 없다.
  - 파일에 너무 작은 공간을 할당했을 경우에는 파일이 커질 수 없다.
  - 특히, `최적 적합` 방식을 사용해서 공간을 할당했다면 양 끝 인접한 공간이 모두 사용 중이기 때문에 파일을 확장시킬 수 없다.
  - 이러한 경우를 방지하기 위해, 처음부터 너무 많은 공간을 할당하면 오히려 `내부 단편화`가 발생하는 문제가 있다.

<img src=" https://mblogthumb-phinf.pstatic.net/20130719_151/jevida_1374214143622BDfq2_PNG/1.png?type=w2" style="zoom:80%;" />

---

#### 2.2 연결 할당 (Linked Allocation)

- `연결 할당`은 연속 할당의 모든 문제를 해결한다.
- `연결 할당`의 경우 파일은 디스크 블록의 연결 리스트 형태로 저장되고 이 디스크 블록들은 디스크 내에 흩어져서 저장될 수 있다.
- `디렉터리`는 파일의 첫 번째와 마지막 블록에 대한 포인터를 가지고 있다.

<img src=" https://t1.daumcdn.net/cfile/tistory/256CC64259197B0A37" style="zoom:80%;" />

#### 연결 할당 방식의 단점

- `직접 접근`을 할 수 없다는 단점이 있다.
  - 파일은 디스크 내에 임의의 위치에 흩어진 블록들의 연결된 상태로 저장되기 때문에 `i 번째` 블록에 접근하기 위해서는 첫 번째 블록부터 순차적으로 탐색해야 한다.
- `포인터`를 위한 공간이 필요하다.
  - 512B내에서 다음 블록을 가리키는 포인터가 4B의 공간을 필요로 한다면 그만큼의 공간을 더 필요로한다.
- 신뢰성의 문제가 있다.
  - 각 블록들이 디스크 내에 흩어져 연결되어 있기 때문에 오류나 고장으로 인해 포인터가 손상되면 모든 데이터를 잃어버릴 수 있다.

#### 파일 할당 테이블  FAT (File Allocation Table)

- `신뢰성`의 문제를 FAT 기법을 사용하여 해결할 수 있다.
- `FAT`는 각 블록이 가지고 있는 포인터를 저장한다.
- 디렉터리의 항목은 각 파일의 첫 번째 블록 번호를 가리키는데, 이 번호를 가지고 `FAT` 테이블로 가면 그 항목은 다음 블록을 가리키고 이러한 과정을 거쳐 마지막 블록까지 접근할 수 있다.
- `FAT` 테이블이 손실될 경우를 대비해서 백업용 FAT 테이블을 가지고 있으며 `FAT`는 해당 파티션의 가장 첫 번째에 저장되어 있기 때문에 디스크 헤드를 이동시켜야 한다.

---

### 3. 색인 할당 (Indexed Allocation)

- `색인 할당`은 파일의 모든 포인터를 하나의 장소, 즉 `색인 블록`을 관리하는 방식이다.
- 각 파일들은 디스크 블록 주소들을 모아놓은 `색인 블록`을 가지는데 `색인 블록`의 `i 번째` 항목은 파일의 `i 번째` 항목을 가리킨다.
- `순차 접근`을 원한다면 `색인 블록`의 첫 번째 항목부터 접근하여 해당 블록에 접근하면 되고,파일의 `i번째` 블록에  `직접 접근`을 원한다면 `색인 블록`의 `i 번째` 항목에 접근하면 된다.

<img src=" https://t1.daumcdn.net/cfile/tistory/2131764259197B0B28" style="zoom:80%;" />

#### 색인 할당 기법의 단점

- 작은 블록만을 필요로하는 파일이라고 할지라도 `색인 할당`기법에서는 하나의 `색인 블록`을 사용해야 하기 때문에 디스크 낭비를 초래할 수 있다.
- 반대로, 파일의 크기가 너무 커서 하나의 `색인 블록`으로 파일의 모든 블록에 대한 참조 값을 저장할 수 없는 경우가 발생할 수 있다.



#### 색인 할당 기법의 단점 해결 방법

1. 연결 기법 (Linked scheme)

   - 하나의 `색인 블록`으로 파일의 모든 블록을 가리킬 수 없다면 여러 개의 `색인 블록`을 연결시키면 된다.
   - 첫 번째 `색인 블록`의 마지막 항목은 다음 `색인 블록`의 헤더를 가리키는 포인터로 설정하면 된다.

2. 다중 수준 색인 (multilevel index)

   - 첫 번째 `색인 블록`은 파일을 가리키는 포인터를 저장하고 있는 또 다른 `색인 블록`을 가리키는 포인터들을 저장한다.

3. 결합 기법 (combined scheme)

   - `색인 블록`의 15개 포인터를 유지하는 방식이다.
   - 처음 12개는 파일의 `직접 블록`을 가리키고 다음의 3개 포인터는 `간접 블록`을 가리키는 포인터이다.
   - 첫 번째 포인터는 `단일 간접 블록`을 가리키는데, 이 블록은 데이터가 아니라 데이터를 가리키는 블록의 주소 저장한다.
   - 두 번째 포인터는 `이중 간접 블록`을 가리키는데, 이 블록은 실제 데이터 블록을 가리키는 포인터를 저장하고 있는 블록의 주소를 저장한다.
   - 세 번째 포인터는 `삼중 간접 블록`을 가리킨다.

   

![]( https://media.geeksforgeeks.org/wp-content/uploads/Combined-Scheme.jpg )

---

### 4. 자유 공간의 관리

- 디스크 공간은 제한되어 있기 때문에 삭제된 파일들이 차지하던 공간을 새로운 파일들을 위하여 다시 재사용해야 한다.
- 운영체제는 이러한 `자유 공간`을 리스트로 유지하고 관리하는데, 새로운 파일을 만들기 위해서는 이 `자유 공간 리스트`를 탐색하여 새로운 파일을 위한 공간을 할당받아야 한다.
- 새로운 파일이 생성되면 `자유 공간 리스트`에서 해당 공간이 삭제되고, 파일이 삭제되면 `자유 공간 리스트`에 새로운 공간이 추가된다.
- `자유 공간 리스트`는 메인 메모리에서 관리하는 것 같다....???



#### 4.1 비트 벡터 (bit vector)

- 자유 공간 리스트는 흔히 `비트맵 또는 비트벡터`로 구현된다.
- 각 블록은 1비트로 표현되며, 블록이 할당되어 있다면 0이고 그렇지 않다면 1이다.
- 블록 번호를 계산하는 방법은 `(워드의 비트 수) x (값이 0인 워드의 수) + 첫 번째 1비트의 변위` 이다.
- `0000110011`과 같은 비트 벡터가 있고 워드의 비트 수가 3이라고 가정할 때, 첫 번째 가용 블록 번호는 `3 x 1 + 2 = 5`이다.

- `비트 벡터`는 그 전체가 메인 메모리에 적재되어 있어야 하기 때문에 디스크의 크기가 클 수록 메인 메모리에서 `비트 벡터`가 차지하는 용량이 커지는 단점이 있다.



#### 4.2 연결 리스트 (Linked List)

- 모든 `자유 블록`들을 연결 리스트 형태로 구현하는 방식이다.
- 이 방식에서 리스트를 순회하려면 매번 디스크를 접근해야 하므로 효율적이지 못하다.
- 하지만 통상적으로 파일에 할당할 `하나의 자유 블록`이 필요하므로 `자유 리스트`의 첫 블록을 사용하기 때문에 디스크에 접근하는 횟수는 그리 크지않다.



#### 4.3 그룹핑 (Grouping)

- 

#### 4.4 계수 (Counting)

- `계수`방식은 `연속 할당 방식`이나 `클러스터링 방식`을 활용하는 경우에 유용하다.
- 모든 블록에 대해서 할당 여부를 추적할 필요없이 연속된 자유 블록의 첫 번째 블록의 주소와 연속된 블록의 개수(count)만 유지하면 효율적이다.
- 