## 1. 프로세스란

- `메인 메모리`에 적재되어 현재 실행중인 프로그램을 프로세스라고 한다.
- `프로그램` 자체는 디스크에 저장된 파일 (실행 파일)과 같은 수동적인 상태이고, 프로세스는 다음 실행할 명령어 (PC) 의 값을 지니는 능동적인 상태라고 할 수 있다.



### 1-1. 프로세스 상태

- 프로세스는 `상태`는 현재의 활동에 따라 정의된다.

![](../자료/프로세스상태도.png)

1. created
   - 프로그램이 실행되기 위해서 커널에 등록되어 프로세스가 된 상태이다.
   - `created` 상태에서 프로세스는 메모리의 가용 공간에 따라 `ready` 상태와 `suspended ready` 상태로 바뀐다.
2. ready
   - 메모리 가용 공간이 충분하여 `ready`상태로 바뀌게 되면, CPU에 할당받기를 기다리는 상태이다.
3. running : 
   - 프로세스가 CPU를 할당받아 명령어를 처리하는 상태를 말한다.
   - 이때, `ready => running` 상태로 바뀌는 것을 `dispatch`라고 한다.
   - `running` 상태에서 다른 프로세스에 의해 CPU 선점을 뺏기게 되면 `ready`상태로 변하게 되고, 입출력과 같은 처리를 위해 대기하는 상태를 `asleep` 상태라고 한다.
4. asleep:
   - 프로세스가 어떤 사건(입출력 등)의 처리를 기다리고 있는 상태이다.
   - 이 과정을 `sleep 혹은 block` 되었다고 한다.
   - `asleep` 상태에서 바로 `running` 상태로 바뀔 수 없고, `wakeup`을 통해 먼저 `ready` 상태로 변해야한다.
5. terminated : 프로세스의 실행이 종료된 상태이다.



### 1-2. PCB (Process Control Block) 

- 프로세스에 대한 모든 정보를 담고 있는 자료구조로서 `이중 연결 리스트`로 표현된다.
- 프로세스 상태, PID, PC, 레지스터 등과 같은 정보들을 담고 있다.



### 1-3. 프로세스 스케줄링

- `프로세스 스케줄러`는 CPU에서 실행 가능한 여러 프로세스등 중에서 하나의 프로세스를 선택하는 일을 한다.



1. 잡 큐 (Job Queue)
   - `long-term`스케줄러 혹은 `잡 스케줄러`에 의해서 디스크에 있는 프로그램이 `메인 메모리`의 `준비 완료 큐`로 적재될 때 사용되는 `secondary storage` 이다.
2.  준비완료 큐 (Ready Queue)
   - 프로세스의 상태가 `ready`에서 `running`을 기다리고 있는 프로세스들이 저장되는 자료구조이다.
   - 이 큐는 일반적으로 연결 리스트로 저장된다. 각각의 PCB들은 다음 PCB를 가리키고 있으며, `준비 완료 큐`의 헤더는 PCB 리스트의 맨 앞과 맨 뒤를 가리키는 포인터를 가진다.
3. 장치 큐 (Device Queue)
   - `running` 상태에 있는 프로세스가 `디스크`와 같은 장치에 입출력을 요구했을 때 각각의 프로세스가 대기하는 자료구조이다.



### 1-4. 스케줄러

- 운영체제는 위에서 설명한 `큐`에서 프로세스를 적절하게 선택해야만 한다.

1. **장기 스케줄러 (Long-Term Scheduler)**

   - `디스크`에 저장되어 있는 프로그램을 메모리로 적재시키는 일을 하는 스케줄러이다.

   - 최선의 성능을 유지하기 위해, `입출력`과 `CPU` 중심의 프로세스를 적절하게 혼합해야한다.

     **- I/O Bound vs CPU Bound**

     - 프로세스들은 입출력 중심의 프로세스와 CPU 중심의 프로세스로 나뉜다.
     - 만약 모든 프로세스가 `입출력`중심의 프로세스라면 `준비 완료 큐`는 항상 비어있을 것이고 `단기 스케줄러`는 할 일이 없어지게 된다.
     - 반대로, 모든 프로세스가 `CPU`중심의 프로세스라면 `장치 큐`는 항상 비어있게 되고 장치들은 사용되지 않아 시스템 균형을 잃게된다.

2. **단기 스케줄러 (Short-Term Scheduler)**

   - `준비 완료 큐`에 저장되어 있는 프로세스들 중에서 CPU를 할당할 프로세스를 선택하는 스케줄러이다.

3. **중기 스케줄러(Medium-Term Scheduler)**

   - 메모리에서 (CPU를 위해 적극적으로 경쟁하는) 프로세스들을 제거함으로써 다중 프로그래밍의 정도를 완화하는 것이다.
   - 차후에 다시 프로세스를 메모리로 불러와서 중단된 시점부터 다시 실행하는 데 이를 `스와핑`이라고 한다.
   - `스와핑`은 메모리 혼잡 상태를 개선하거나 요구되는 메모리가 가용 메모리보다 클 때 사용된다.

   

#### **장기 스케줄러 vs 단기 스케줄러**

- `장기 스케줄러`의 실행 빈도 수가 훨씬 적다.  `장기 스케줄러`의 다중 프로그램의 정도(메모리에 있는 프로세스의 수)가 안정적이면, 평균 프로세스 생성률이 시스템을 떠나는 평균 프로세스 이탈율과 반드시 동일해야 한다.
- 그러므로, `장기 스케줄러`는 프로세스가 시스템을 떠날 때에만 호출될 수 있다.
- 이에 반해, 단기 스케줄러는 프로세스의 지연을 최소화 해야하므로 실행 간격이 짧아 빈도수가 높다.



### 1-5. 문맥 교환 (Context Switch)

- CPU를 점유하고 있는 프로세스를 다른 프로세스로 교체하려면, 커널은 현재 프로세스의 정보를 PCB에 저장하고 새로운 프로세스의 정보를 PCB를 통해 복구하는 작업이 필요하다.
- `문맥 교환`이 일어나는 동안에는 시스템이 일을 하지 못하기 떄문에, `문맥 교환`시간은 순수한 오버헤드 시간이다.



## 2. 프로세스간 통신

### 2-1. 프로세스의 종류

1. 독립 프로세스 (Independent Process)
   - 다른 프로세스에 영향을 끼치지도 받지도 않는 프로세스를 말한다.
2. 협력 프로세스 (Cooperating Process)
   - 다른 프로레스와 영향을 주고 받으며 `자원`을 공유하는 프로세스를 말한다.



### 2-1. IPC(Inter-Process Communication)이란?

- `협력 프로세스` 사이에서 서로 데이터를 주고 받는 행위 또는 그에 대한 방법이나 경로를 말한다.
- 즉, `협력 프로세스` 간의 통신을 위해 커널이 제공하는 여러가지의 `IPC` 설비를 이용한다.
- **기본적으로, 서로 다른 프로세스간의 메모리 접근이 막혀있기 때문에 `IPC`가 필요하다라고 생각하면 될 것 같다.**



### 2-2. 메시지 전달(Messaging Passing) vs 공유 메모리(Shared Memory)

- IPC 기법에는 크게 `메시지 전달`방식과 `공유 메모리` 방식 두 가지가 있다.

![](https://t1.daumcdn.net/cfile/tistory/99B096385C4C756932)



#### 2-2-1. 공유 메모리 (Shared Memory)

- 협력 프로세스들 사이에 공유되는 메모리 영역이 구축하고, 이 영역에 메모리를 읽고 쓰고 함으로써 정보를 교환할 수 있다.
- 이 방식은 시스템 호출을 통해 커널의 간섭이 발생하는 `메시지 전달` 방식보다 빠르다는 장점이 있다.

#### **생산자 - 소비자 문제**

- `생산자` 프로세스는 정보를 생산하고, `소비자 `프로세스는 정보를 소비한다.
- 생산자 - 소비자 프로세스들이 병행으로 실행되도록 하려면 생산자가 정보를 채워놓고 소비자가 정보를 가져가는 버퍼가 반드시 필요하다.

#### **유한 버퍼**

- `유한 버퍼`는 버퍼의 크기가 고정되어 있다고 가정한다.
- `버퍼`가 꽉 차있으면 생산자가 대기해야하고, `버퍼`가 비어있으면 소비자가 대기해야만 한다.

```c
#define BUFFER_SIZE 10

typedef struct {
    .....
} item;

item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
```

- 공유 버퍼는 포인터 `in`과 `out`을 갖는 원형 배열로 구현된다. 
- 변수 `in`은 버퍼 내에서 다음으로 비어 있는 위치를 가리키며, `out`은 버퍼 내에서 첫 번째로 차 있는 위치를 가리킨다.
- `in == out` 일때 버퍼는 비어 있고, `(in + 1) % BUFFER_SIZE == out` 일 때, 버퍼는 가득 차있다.

```c
//생산자 코드
item next_produced;

while(true){
	//next_produced 에 다음 번 생성되는 데이터를 저장
    while( (in + 1) % BUFFER_SIZE == out){
        // 버퍼가 가득 차있으므로, 아무 일도 하지 않는다.
    }
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
}

//소비자 코드
item next_consumed;

while(true){
    while(in == out){
        //버퍼가 비어있으므로, 아무 일도 하지 않는다.
    }
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
}
```



### 2-2-2. 메시지 전달 (Message-Passing System)

- 커널이 각 프로세스의 Memory protection을 위해 데이터를 대리 전달해주는 방식이다.
- 따라서, 안전하고 동기화로 인한 문제가 없지만 성능이 떨어진다는 단점이 있다.
- 그 이유는, 커널이 데이터를 전달해주는 역할을 한다는 것은 커널 내부에 데이터를 어딘가에 저장해야 한다는 뜻이며, 직접 전달하는 방식에 비해서는 느릴 수 밖에 없다.
- 또한, 커널을 통해 데이터를 전달하기 때문에 그때마다 `시스템 콜`을 호출함으로써 `오버헤드`가 증가하게 된다.

#### Direct Communication

- `Direct`  방식은 커널이 직접 다른 프로세스에게 전달하는 방법이다.



#### Indirect Communication

- `Indirect` 방식은 데이터를 커널이 직접 전달하는 것이 아니라, `메일 박스`에 데이터를 저장하고 이 데이터가 필요한 프로세스가 데이터를 가져가도록 하는 방식이다.