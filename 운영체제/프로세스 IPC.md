## 1. 프로세스의 종류

1. 독립 프로세스 (Independent Process)
   - 다른 프로세스에 영향을 끼치지도 받지도 않는 프로세스를 말한다.
2. 협력 프로세스 (Cooperating Process)
   - 다른 프로레스와 영향을 주고 받으며 `자원`을 공유하는 프로세스를 말한다.



## 2. IPC(Inter-Process Communication)이란?

- `협력 프로세스` 사이에서 서로 데이터를 주고 받는 행위 또는 그에 대한 방법이나 경로를 말한다.

- 즉, `협력 프로세스` 간의 통신을 위해 커널이 제공하는 여러가지의 `IPC` 설비를 이용한다.
- **기본적으로, 서로 다른 프로세스간의 메모리 접근이 막혀있기 때문에 `IPC`가 필요하다라고 생각하면 될 것 같다.**



## 3. 메시지 교환 (Messaging Passing) vs 데이터 공유 (Shared Memory)



![](https://t1.daumcdn.net/cfile/tistory/99B096385C4C756932)



### 1. 메시지 교환 (Messaging Passing)

- 커널이 각 프로세스의 Memory protection을 위해 데이터를 대리 전달해주는 방식이다.
- 따라서, 안전하고 동기화로 인한 문제가 없지만 성능이 떨어진다는 단점이 있다.
- 그 이유는, 커널이 데이터를 전달해주는 역할을 한다는 것은 커널 내부에 데이터를 어딘가에 저장해야 한다는 뜻이며, 직접 전달하는 방식에 비해서는 느릴 수 밖에 없다.
- 또한, 커널을 통해 데이터를 전달하기 때문에 그때마다 `시스템 콜`을 호출함으로써 `오버헤드`가 증가하게 된다.



#### 1-1. Direct Communication

- `Direct`  방식은 커널이 직접 다른 프로세스에게 전달하는 방법이다.

  

#### 1-2 Indirect Communication

- `Indirect` 방식은 데이터를 커널이 직접 전달하는 것이 아니라, `메일 박스`에 데이터를 저장하고 이 데이터가 필요한 프로세스가 데이터를 가져가도록 하는 방식이다.



### 2. 데이터 공유 (Shared Memory)

- 보통 각 프로세스들은 독립적인 `메모리 영역`을 가지고 있지만, 프로세스간의 통신이 필요할 경우에는 특정 메모리 영역을 공유할 수 있다.
- 이때 발생하는 문제점은 바로 동기화 문제이다. 공통된 `메모리 영역`에 여러 프로세스가 동시에 접근하면 신뢰성을 상실할 수 있는 문제가 있다.
- `메시지 교환` 방식과 달리, 데이터를 전달하는 매개체가 있는 것이 아니기 때문에 빠른 수행 속도를 보여준다.



### 4. 동기화 문제

- `동기화`란, 하나의 공유자원에 여러 프로세스(스레드)가 접근할 때 데이터의 신뢰성을 보장하기 위한 일련의 작업이다.
- 즉, 프로세스(스레드)가 수행되는 시점을 조절하는 것을 `동기화`라고 할 수 있다.

```java
int withdraw(account, amount){
    balance = get_balance(account); // 1. 잔액을 가져옴
    balance = balance - amount;		// 2. 기존 잔액에서 출금할 금액을 뺀 금액
    put_balance(balance);			// 3. 출금 후 잔액을 갱신
    return balance;
}
```

- 위의 코드에서 두 개의 프로세스가 동시에 withdraw 메소드를 호출하는 경우를 생각해보자.
- 프로세스 A가 withdraw 메소드를 실행하다가 `balance = balance - amount` 명령어를 실행한 직후 `컨텍스트 스위칭`이 발생했다고 가정하자.
- 프로세스 A가 `amount`만큼의 금액을 출금했음에도 불구하고, 프로세스 B가 `get_balance(account)` 메소드를 호출해서 얻는 금액은 프로세스 A가 출금하기 전의 금액과 같다.
- 이처럼, `동기화`가 이뤄지지 않으면 데이터 신뢰성에 큰 문제가 발생하게 된다.



### 5. 임계영역 (Critical Section) 이란?

- 위의 예제에서처럼, 여러 개의 프로세스가 동시에 접근하면 안되는 영역을 `임계 구역`이라고 한다.



#### 5-1 임계영역 문제 해결 방법

1. 상호배제 (Mutual Exclusion) : 하나의 프로세스가 임계구역에 들어가 있으면, 다른 프로세스는 들어갈 수 없다.
2. 진행 (Progress) : 임계구역에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 선택해야한다.
3. 한정대기 (Bounded Waiting) : `기아 상태`를 방지하기 위해 한 번 들어갔다가 나온 프로세스는 제한을 준다. 즉, 어느 프로세스라도 정해진 시간내에 언젠가는 `임계 구역`에 들어가야 한다.



#### 5-2 소프트웨어 해결방법 vs 하드웨어 해결방법



#### 5-2-1. 소프트웨어 해결방법 (Spin Lock) => 하드웨어 방법인가...??? (TestAndSet??)

- 이전에 살펴봤던 코드에 `lock` 방법을 적용해보자.

```java
int withdraw(account, amount){
    lock();
    balance = get_balance(account); // 1. 잔액을 가져옴
    balance = balance - amount;		// 2. 기존 잔액에서 출금할 금액을 뺀 금액
    put_balance(balance);			// 3. 출금 후 잔액을 갱신
    unlock();
    return balance;
}
```

- 프로세스 A와 B가 `withdraw` 메소드를 호출한다고 가정해보자.
- 먼저, 프로세스 A가 `withdraw` 메소드에서 `lock()` 메소드를 호출한다. 초기에는 `Lock`이 걸려있지 않기 때문에 `Lock`을 걸고, 코드를 계속 실행한다.
- `balance = get_balance(account)` 코드를 수행하고 난뒤, `컨텍스트 스위칭`이 발생하여 프로세스 B가 `withdraw`메소드를 호출한다고 가정하자.
- B가 `lock()` 메소드를 호출하려고 하면, 이미 `Lock`이 되어있는 상태이므로 `Lock`이 해제될때까지 무한정으로 기다리게 된다. (이를 busy wait이라고 한다.)
- 다시 `컨텍스트 스위칭`이 발생하여 프로세스 A가 `balance = balance - amount` 코드부터 수행한뒤 `unlock()` 메소드를 호출하여 `Lock`을 해제하고, 다시 프로세스 B가 수행된다.
- 프로세스 B는 `Lock`이 해제된 상태이므로 `balance = get_balance(account)` 코드부터 순차적으로 수행한다.

#### **-Lock 함수의 구현**

```java
class Lock{	//Lock 클래스는 싱글톤이라고 가정한다. 즉, 프로세스들은 하나의 flag 변수를 공유한다.
	boolean flag;
    public Lock(boolean flag){
        this.flag = flag;
    }
    
    void lock(){
        while(flag){	//lock이 걸린 상태라면 무한루프 => busy wait 발생
            			
        }
        flag = true;
    }
    
    void unlock(){
        flag = false;
    }
}
```

- `Spin Lock`은 임계구역 문제를 해결하기 위한 방법이라고 설명했지만, 이 자체로 `임계 구역`문제를 안고 있다.

- 예를 들어, 프로세스(스레드) A가 초기상태에서 `lock()` 메소드를 호출하고 반복문을 빠져나온 직후에 `인터럽트`가 발생하여 CPU를 프로세스(스레드) B가 선점하였다고 가정하자.

- 프로세스 A가 `flag = true` 를 실행하기 전에 인터럽트가 발생했으므로, 프로세스 B 또한 반복문을 빠져나와 임계구역에 진입할 수 있게 된다. 프로세스 B가 임계구역에 있을 때, 다시 한번 인터럽트가 발생하여 프로세스 A가 CPU를 선점하게 된다.

- 프로세스 A는 이전 반복문 직후에 인터럽트가 발생했으므로 해당 시점부터 다시 수행하는데, 이 상황이 프로세스 A와 B가 모두 임계 구역에 진입하게 되는 상황이다.

  

#### **- 바쁜 대기 (Busy Waiting)이란?**

- 원하는 자원을 얻기 위해 기다리는 것이 아니라, 권한을 얻을 때 까지 계속해서 확인하는 것을 의미한다.
- `busy waiting`의 단점은 권한 획득을 위해 CPU를 낭비한다는 단점이 있다.



#### **- Spin Lock의 특징**

1. `Lock`을 얻을 때까지 계속해서 확인을 하는 `busy wait` 방식이다.
2. `Lock` 이 곧 사용 가능해질 경우 `컨텍스트 스위칭`을 줄여 CPU의 부담을 덜어주지만, 오랜 시간 동안 `Lock`을 얻지 못해 무한 루프를 돌게되면 많은 CPU자원을 소비한다.

3. 하나의 CPU 코어만 있는 경우에는 유용하지 않다. 그 이유는 다른 스레드가 `Lock`을 반환할 경우 싱글 스레드 CPU 시스템에서는 어차피 `컨텍스트 스위칭`이 발생해야만 하기 때문이다.



#### 5-2-2. 소프트웨어 해결방법 (피터슨의 알고리즘)

- `피터슨의 알고리즘`은 `상호 배제`를 위한 알고리즘으로서 `임계 구역` 문제를 해결하는 알고리즘이다.
- `피터슨의 알고리즘`은 `상호 배제`, `진행`, `한정 대기` 조건을 모두  만족한다.
- 발표 당시의 알고리즘은 프로세스가 2개인 경우만 적용 가능하고, 이후 3개 이상의 경우에도 적용할 수 있는 방법이 논의되었다. (현재는 3개 이상의 프로세스에 대해서도 가능하다고.....)

```java
boolean flag[2]; // flag[i] = true 는 i번째 프로세스가 임계구역을 사용하길 원한다는 뜻이다.
int turn;		// turn은 프로세스를 가리킨다. turn = 0은 0번 프로세스를 나타낸다.

P0 : 
flag[0] = true; 	// 0번 프로세스가 임계구역을 사용하길 원하는 상황이다.
turn = 1;			// 임계구역을 사용할 수 있는 프로세스를 1번 프로세스로 설정한다.
while(flag[1] && turn == 1){	//사용을 할 수 있는지 계속해서 확인한다. (busy waiting)
    
}
//	임계구역의 시작
//	임계구역
//	임계구역의 끝
flag[0] = false;

P1 :
flag[1] = true;
turn = 0;
while(flag[0] && turn == 0){
    
}
//	임계구역의 시작
//	임계구역
//	임계구역의 끝
flag[1] = false;
```

- 프로세스 P0과 P1이 거의 동시에 `임계 구역`에 들어가고 싶어한다고 하더라도, `turn` 값은 어느 한 값으로 덮어씌어지게 된다.
- 즉, `피터슨의 알고리즘은` 마지막에 결정된 `turn` 값에 의해 두 개의 프로세스 중 어떤 프로세스가 먼저 공유 자원을 사용할지 결정하는 알고리즘이다.

```java
P0:
turn = 1;	// 0번 프로세스가 있어야 1번 프로세스가 실행될 수 있기 때문에 `한정 대기`조건을 만족한다.
while(flag[1] && turn == 1){
    // 1번 프로세스가 임계구역을 사용하고 있으면 무한 루프를 돌기 때문에 `상호배제` 조건을 만족한다.
    // 다른 프로세스가 임계구역을 사용하지 않고 있으면 (flag[1] == false) 임계구역을 사용할 수 있다.
    // `진행` 조건을 만족한다.
}
......
flag[0] = false;
```



#### 5-3. 하드웨어 해결방법 (세마포어)











